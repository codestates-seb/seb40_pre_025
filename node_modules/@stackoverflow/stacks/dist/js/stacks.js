(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Stacks"] = factory();
	else
		root["Stacks"] = factory();
})(globalThis, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 492:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "afterMain": () => (/* reexport */ afterMain),
  "afterRead": () => (/* reexport */ afterRead),
  "afterWrite": () => (/* reexport */ afterWrite),
  "applyStyles": () => (/* reexport */ modifiers_applyStyles),
  "arrow": () => (/* reexport */ modifiers_arrow),
  "auto": () => (/* reexport */ auto),
  "basePlacements": () => (/* reexport */ basePlacements),
  "beforeMain": () => (/* reexport */ beforeMain),
  "beforeRead": () => (/* reexport */ beforeRead),
  "beforeWrite": () => (/* reexport */ beforeWrite),
  "bottom": () => (/* reexport */ bottom),
  "clippingParents": () => (/* reexport */ clippingParents),
  "computeStyles": () => (/* reexport */ modifiers_computeStyles),
  "createPopper": () => (/* reexport */ popper_createPopper),
  "createPopperBase": () => (/* reexport */ createPopper),
  "createPopperLite": () => (/* reexport */ popper_lite_createPopper),
  "detectOverflow": () => (/* reexport */ detectOverflow),
  "end": () => (/* reexport */ end),
  "eventListeners": () => (/* reexport */ eventListeners),
  "flip": () => (/* reexport */ modifiers_flip),
  "hide": () => (/* reexport */ modifiers_hide),
  "left": () => (/* reexport */ left),
  "main": () => (/* reexport */ main),
  "modifierPhases": () => (/* reexport */ modifierPhases),
  "offset": () => (/* reexport */ modifiers_offset),
  "placements": () => (/* reexport */ enums_placements),
  "popper": () => (/* reexport */ popper),
  "popperGenerator": () => (/* reexport */ popperGenerator),
  "popperOffsets": () => (/* reexport */ modifiers_popperOffsets),
  "preventOverflow": () => (/* reexport */ modifiers_preventOverflow),
  "read": () => (/* reexport */ read),
  "reference": () => (/* reexport */ reference),
  "right": () => (/* reexport */ right),
  "start": () => (/* reexport */ start),
  "top": () => (/* reexport */ enums_top),
  "variationPlacements": () => (/* reexport */ variationPlacements),
  "viewport": () => (/* reexport */ viewport),
  "write": () => (/* reexport */ write)
});

;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js
var enums_top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [enums_top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js


function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}


;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_applyStyles = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js

function getBasePlacement(placement) {
  return placement.split('-')[0];
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/math.js
var math_max = Math.max;
var math_min = Math.min;
var round = Math.round;
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function (item) {
      return item.brand + "/" + item.version;
    }).join(' ');
  }

  return navigator.userAgent;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js

function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js




function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  var _ref = isElement(element) ? getWindow(element) : window,
      visualViewport = _ref.visualViewport;

  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x: x,
    y: y
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js



function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js








function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js

function within(min, value, max) {
  return math_max(min, math_min(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/arrow.js









 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? enums_top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function arrow_effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (false) {}

  if (!contains(state.elements.popper, arrowElement)) {
    if (false) {}

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_arrow = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: arrow_effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split('-')[1];
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = enums_top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === enums_top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (false) { var transitionProperty; }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_computeStyles = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function eventListeners_effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const eventListeners = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: eventListeners_effect,
  data: {}
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var getOppositeVariationPlacement_hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return getOppositeVariationPlacement_hash[matched];
  });
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js




function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js















function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === 'fixed');
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = math_max(rect.top, accRect.top);
    accRect.right = math_min(rect.right, accRect.right);
    accRect.bottom = math_min(rect.bottom, accRect.bottom);
    accRect.left = math_max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case enums_top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$strategy = _options.strategy,
      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;

    if (false) {}
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_flip = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [enums_top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_hide = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = enums_placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_offset = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_popperOffsets = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? enums_top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? enums_top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const modifiers_preventOverflow = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/index.js









;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js




function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}
;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/createPopper.js














var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (false) {}

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (false) {}

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (false) {}

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules


;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper.js










var defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];
var popper_createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules


;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper-lite.js





var popper_lite_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles];
var popper_lite_createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: popper_lite_defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules


;// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/index.js

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ 708:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 931:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Application": () => (/* reexport */ Application),
  "Context": () => (/* reexport */ Context),
  "Controller": () => (/* reexport */ Controller),
  "defaultSchema": () => (/* reexport */ defaultSchema)
});

;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/event_listener.js
var EventListener = /** @class */ (function () {
    function EventListener(eventTarget, eventName, eventOptions) {
        this.eventTarget = eventTarget;
        this.eventName = eventName;
        this.eventOptions = eventOptions;
        this.unorderedBindings = new Set();
    }
    EventListener.prototype.connect = function () {
        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    };
    EventListener.prototype.disconnect = function () {
        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    };
    // Binding observer delegate
    /** @hidden */
    EventListener.prototype.bindingConnected = function (binding) {
        this.unorderedBindings.add(binding);
    };
    /** @hidden */
    EventListener.prototype.bindingDisconnected = function (binding) {
        this.unorderedBindings.delete(binding);
    };
    EventListener.prototype.handleEvent = function (event) {
        var extendedEvent = extendEvent(event);
        for (var _i = 0, _a = this.bindings; _i < _a.length; _i++) {
            var binding = _a[_i];
            if (extendedEvent.immediatePropagationStopped) {
                break;
            }
            else {
                binding.handleEvent(extendedEvent);
            }
        }
    };
    Object.defineProperty(EventListener.prototype, "bindings", {
        get: function () {
            return Array.from(this.unorderedBindings).sort(function (left, right) {
                var leftIndex = left.index, rightIndex = right.index;
                return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
            });
        },
        enumerable: false,
        configurable: true
    });
    return EventListener;
}());

function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
        return event;
    }
    else {
        var stopImmediatePropagation_1 = event.stopImmediatePropagation;
        return Object.assign(event, {
            immediatePropagationStopped: false,
            stopImmediatePropagation: function () {
                this.immediatePropagationStopped = true;
                stopImmediatePropagation_1.call(this);
            }
        });
    }
}
//# sourceMappingURL=event_listener.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/dispatcher.js

var Dispatcher = /** @class */ (function () {
    function Dispatcher(application) {
        this.application = application;
        this.eventListenerMaps = new Map;
        this.started = false;
    }
    Dispatcher.prototype.start = function () {
        if (!this.started) {
            this.started = true;
            this.eventListeners.forEach(function (eventListener) { return eventListener.connect(); });
        }
    };
    Dispatcher.prototype.stop = function () {
        if (this.started) {
            this.started = false;
            this.eventListeners.forEach(function (eventListener) { return eventListener.disconnect(); });
        }
    };
    Object.defineProperty(Dispatcher.prototype, "eventListeners", {
        get: function () {
            return Array.from(this.eventListenerMaps.values())
                .reduce(function (listeners, map) { return listeners.concat(Array.from(map.values())); }, []);
        },
        enumerable: false,
        configurable: true
    });
    // Binding observer delegate
    /** @hidden */
    Dispatcher.prototype.bindingConnected = function (binding) {
        this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    };
    /** @hidden */
    Dispatcher.prototype.bindingDisconnected = function (binding) {
        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
    };
    // Error handling
    Dispatcher.prototype.handleError = function (error, message, detail) {
        if (detail === void 0) { detail = {}; }
        this.application.handleError(error, "Error " + message, detail);
    };
    Dispatcher.prototype.fetchEventListenerForBinding = function (binding) {
        var eventTarget = binding.eventTarget, eventName = binding.eventName, eventOptions = binding.eventOptions;
        return this.fetchEventListener(eventTarget, eventName, eventOptions);
    };
    Dispatcher.prototype.fetchEventListener = function (eventTarget, eventName, eventOptions) {
        var eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        var cacheKey = this.cacheKey(eventName, eventOptions);
        var eventListener = eventListenerMap.get(cacheKey);
        if (!eventListener) {
            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
            eventListenerMap.set(cacheKey, eventListener);
        }
        return eventListener;
    };
    Dispatcher.prototype.createEventListener = function (eventTarget, eventName, eventOptions) {
        var eventListener = new EventListener(eventTarget, eventName, eventOptions);
        if (this.started) {
            eventListener.connect();
        }
        return eventListener;
    };
    Dispatcher.prototype.fetchEventListenerMapForEventTarget = function (eventTarget) {
        var eventListenerMap = this.eventListenerMaps.get(eventTarget);
        if (!eventListenerMap) {
            eventListenerMap = new Map;
            this.eventListenerMaps.set(eventTarget, eventListenerMap);
        }
        return eventListenerMap;
    };
    Dispatcher.prototype.cacheKey = function (eventName, eventOptions) {
        var parts = [eventName];
        Object.keys(eventOptions).sort().forEach(function (key) {
            parts.push("" + (eventOptions[key] ? "" : "!") + key);
        });
        return parts.join(":");
    };
    return Dispatcher;
}());

//# sourceMappingURL=dispatcher.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/action_descriptor.js
// capture nos.:            12   23 4               43   1 5   56 7      768 9  98
var descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;
function parseActionDescriptorString(descriptorString) {
    var source = descriptorString.trim();
    var matches = source.match(descriptorPattern) || [];
    return {
        eventTarget: parseEventTarget(matches[4]),
        eventName: matches[2],
        eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},
        identifier: matches[5],
        methodName: matches[7]
    };
}
function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
        return window;
    }
    else if (eventTargetName == "document") {
        return document;
    }
}
function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce(function (options, token) {
        var _a;
        return Object.assign(options, (_a = {}, _a[token.replace(/^!/, "")] = !/^!/.test(token), _a));
    }, {});
}
function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
        return "window";
    }
    else if (eventTarget == document) {
        return "document";
    }
}
//# sourceMappingURL=action_descriptor.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/action.js

var Action = /** @class */ (function () {
    function Action(element, index, descriptor) {
        this.element = element;
        this.index = index;
        this.eventTarget = descriptor.eventTarget || element;
        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
        this.eventOptions = descriptor.eventOptions || {};
        this.identifier = descriptor.identifier || error("missing identifier");
        this.methodName = descriptor.methodName || error("missing method name");
    }
    Action.forToken = function (token) {
        return new this(token.element, token.index, parseActionDescriptorString(token.content));
    };
    Action.prototype.toString = function () {
        var eventNameSuffix = this.eventTargetName ? "@" + this.eventTargetName : "";
        return "" + this.eventName + eventNameSuffix + "->" + this.identifier + "#" + this.methodName;
    };
    Object.defineProperty(Action.prototype, "eventTargetName", {
        get: function () {
            return stringifyEventTarget(this.eventTarget);
        },
        enumerable: false,
        configurable: true
    });
    return Action;
}());

var defaultEventNames = {
    "a": function (e) { return "click"; },
    "button": function (e) { return "click"; },
    "form": function (e) { return "submit"; },
    "input": function (e) { return e.getAttribute("type") == "submit" ? "click" : "input"; },
    "select": function (e) { return "change"; },
    "textarea": function (e) { return "input"; }
};
function getDefaultEventNameForElement(element) {
    var tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
        return defaultEventNames[tagName](element);
    }
}
function error(message) {
    throw new Error(message);
}
//# sourceMappingURL=action.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/binding.js
var Binding = /** @class */ (function () {
    function Binding(context, action) {
        this.context = context;
        this.action = action;
    }
    Object.defineProperty(Binding.prototype, "index", {
        get: function () {
            return this.action.index;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "eventTarget", {
        get: function () {
            return this.action.eventTarget;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "eventOptions", {
        get: function () {
            return this.action.eventOptions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "identifier", {
        get: function () {
            return this.context.identifier;
        },
        enumerable: false,
        configurable: true
    });
    Binding.prototype.handleEvent = function (event) {
        if (this.willBeInvokedByEvent(event)) {
            this.invokeWithEvent(event);
        }
    };
    Object.defineProperty(Binding.prototype, "eventName", {
        get: function () {
            return this.action.eventName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "method", {
        get: function () {
            var method = this.controller[this.methodName];
            if (typeof method == "function") {
                return method;
            }
            throw new Error("Action \"" + this.action + "\" references undefined method \"" + this.methodName + "\"");
        },
        enumerable: false,
        configurable: true
    });
    Binding.prototype.invokeWithEvent = function (event) {
        try {
            this.method.call(this.controller, event);
        }
        catch (error) {
            var _a = this, identifier = _a.identifier, controller = _a.controller, element = _a.element, index = _a.index;
            var detail = { identifier: identifier, controller: controller, element: element, index: index, event: event };
            this.context.handleError(error, "invoking action \"" + this.action + "\"", detail);
        }
    };
    Binding.prototype.willBeInvokedByEvent = function (event) {
        var eventTarget = event.target;
        if (this.element === eventTarget) {
            return true;
        }
        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
            return this.scope.containsElement(eventTarget);
        }
        else {
            return this.scope.containsElement(this.action.element);
        }
    };
    Object.defineProperty(Binding.prototype, "controller", {
        get: function () {
            return this.context.controller;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "methodName", {
        get: function () {
            return this.action.methodName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "element", {
        get: function () {
            return this.scope.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "scope", {
        get: function () {
            return this.context.scope;
        },
        enumerable: false,
        configurable: true
    });
    return Binding;
}());

//# sourceMappingURL=binding.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/element_observer.js
var ElementObserver = /** @class */ (function () {
    function ElementObserver(element, delegate) {
        var _this = this;
        this.element = element;
        this.started = false;
        this.delegate = delegate;
        this.elements = new Set;
        this.mutationObserver = new MutationObserver(function (mutations) { return _this.processMutations(mutations); });
    }
    ElementObserver.prototype.start = function () {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, { attributes: true, childList: true, subtree: true });
            this.refresh();
        }
    };
    ElementObserver.prototype.stop = function () {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    };
    ElementObserver.prototype.refresh = function () {
        if (this.started) {
            var matches = new Set(this.matchElementsInTree());
            for (var _i = 0, _a = Array.from(this.elements); _i < _a.length; _i++) {
                var element = _a[_i];
                if (!matches.has(element)) {
                    this.removeElement(element);
                }
            }
            for (var _b = 0, _c = Array.from(matches); _b < _c.length; _b++) {
                var element = _c[_b];
                this.addElement(element);
            }
        }
    };
    // Mutation record processing
    ElementObserver.prototype.processMutations = function (mutations) {
        if (this.started) {
            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
                var mutation = mutations_1[_i];
                this.processMutation(mutation);
            }
        }
    };
    ElementObserver.prototype.processMutation = function (mutation) {
        if (mutation.type == "attributes") {
            this.processAttributeChange(mutation.target, mutation.attributeName);
        }
        else if (mutation.type == "childList") {
            this.processRemovedNodes(mutation.removedNodes);
            this.processAddedNodes(mutation.addedNodes);
        }
    };
    ElementObserver.prototype.processAttributeChange = function (node, attributeName) {
        var element = node;
        if (this.elements.has(element)) {
            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
                this.delegate.elementAttributeChanged(element, attributeName);
            }
            else {
                this.removeElement(element);
            }
        }
        else if (this.matchElement(element)) {
            this.addElement(element);
        }
    };
    ElementObserver.prototype.processRemovedNodes = function (nodes) {
        for (var _i = 0, _a = Array.from(nodes); _i < _a.length; _i++) {
            var node = _a[_i];
            var element = this.elementFromNode(node);
            if (element) {
                this.processTree(element, this.removeElement);
            }
        }
    };
    ElementObserver.prototype.processAddedNodes = function (nodes) {
        for (var _i = 0, _a = Array.from(nodes); _i < _a.length; _i++) {
            var node = _a[_i];
            var element = this.elementFromNode(node);
            if (element && this.elementIsActive(element)) {
                this.processTree(element, this.addElement);
            }
        }
    };
    // Element matching
    ElementObserver.prototype.matchElement = function (element) {
        return this.delegate.matchElement(element);
    };
    ElementObserver.prototype.matchElementsInTree = function (tree) {
        if (tree === void 0) { tree = this.element; }
        return this.delegate.matchElementsInTree(tree);
    };
    ElementObserver.prototype.processTree = function (tree, processor) {
        for (var _i = 0, _a = this.matchElementsInTree(tree); _i < _a.length; _i++) {
            var element = _a[_i];
            processor.call(this, element);
        }
    };
    ElementObserver.prototype.elementFromNode = function (node) {
        if (node.nodeType == Node.ELEMENT_NODE) {
            return node;
        }
    };
    ElementObserver.prototype.elementIsActive = function (element) {
        if (element.isConnected != this.element.isConnected) {
            return false;
        }
        else {
            return this.element.contains(element);
        }
    };
    // Element tracking
    ElementObserver.prototype.addElement = function (element) {
        if (!this.elements.has(element)) {
            if (this.elementIsActive(element)) {
                this.elements.add(element);
                if (this.delegate.elementMatched) {
                    this.delegate.elementMatched(element);
                }
            }
        }
    };
    ElementObserver.prototype.removeElement = function (element) {
        if (this.elements.has(element)) {
            this.elements.delete(element);
            if (this.delegate.elementUnmatched) {
                this.delegate.elementUnmatched(element);
            }
        }
    };
    return ElementObserver;
}());

//# sourceMappingURL=element_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/attribute_observer.js

var AttributeObserver = /** @class */ (function () {
    function AttributeObserver(element, attributeName, delegate) {
        this.attributeName = attributeName;
        this.delegate = delegate;
        this.elementObserver = new ElementObserver(element, this);
    }
    Object.defineProperty(AttributeObserver.prototype, "element", {
        get: function () {
            return this.elementObserver.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AttributeObserver.prototype, "selector", {
        get: function () {
            return "[" + this.attributeName + "]";
        },
        enumerable: false,
        configurable: true
    });
    AttributeObserver.prototype.start = function () {
        this.elementObserver.start();
    };
    AttributeObserver.prototype.stop = function () {
        this.elementObserver.stop();
    };
    AttributeObserver.prototype.refresh = function () {
        this.elementObserver.refresh();
    };
    Object.defineProperty(AttributeObserver.prototype, "started", {
        get: function () {
            return this.elementObserver.started;
        },
        enumerable: false,
        configurable: true
    });
    // Element observer delegate
    AttributeObserver.prototype.matchElement = function (element) {
        return element.hasAttribute(this.attributeName);
    };
    AttributeObserver.prototype.matchElementsInTree = function (tree) {
        var match = this.matchElement(tree) ? [tree] : [];
        var matches = Array.from(tree.querySelectorAll(this.selector));
        return match.concat(matches);
    };
    AttributeObserver.prototype.elementMatched = function (element) {
        if (this.delegate.elementMatchedAttribute) {
            this.delegate.elementMatchedAttribute(element, this.attributeName);
        }
    };
    AttributeObserver.prototype.elementUnmatched = function (element) {
        if (this.delegate.elementUnmatchedAttribute) {
            this.delegate.elementUnmatchedAttribute(element, this.attributeName);
        }
    };
    AttributeObserver.prototype.elementAttributeChanged = function (element, attributeName) {
        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
            this.delegate.elementAttributeValueChanged(element, attributeName);
        }
    };
    return AttributeObserver;
}());

//# sourceMappingURL=attribute_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/string_map_observer.js
var StringMapObserver = /** @class */ (function () {
    function StringMapObserver(element, delegate) {
        var _this = this;
        this.element = element;
        this.delegate = delegate;
        this.started = false;
        this.stringMap = new Map;
        this.mutationObserver = new MutationObserver(function (mutations) { return _this.processMutations(mutations); });
    }
    StringMapObserver.prototype.start = function () {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, { attributes: true });
            this.refresh();
        }
    };
    StringMapObserver.prototype.stop = function () {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    };
    StringMapObserver.prototype.refresh = function () {
        if (this.started) {
            for (var _i = 0, _a = this.knownAttributeNames; _i < _a.length; _i++) {
                var attributeName = _a[_i];
                this.refreshAttribute(attributeName);
            }
        }
    };
    // Mutation record processing
    StringMapObserver.prototype.processMutations = function (mutations) {
        if (this.started) {
            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
                var mutation = mutations_1[_i];
                this.processMutation(mutation);
            }
        }
    };
    StringMapObserver.prototype.processMutation = function (mutation) {
        var attributeName = mutation.attributeName;
        if (attributeName) {
            this.refreshAttribute(attributeName);
        }
    };
    // State tracking
    StringMapObserver.prototype.refreshAttribute = function (attributeName) {
        var key = this.delegate.getStringMapKeyForAttribute(attributeName);
        if (key != null) {
            if (!this.stringMap.has(attributeName)) {
                this.stringMapKeyAdded(key, attributeName);
            }
            var value = this.element.getAttribute(attributeName);
            if (this.stringMap.get(attributeName) != value) {
                this.stringMapValueChanged(value, key);
            }
            if (value == null) {
                this.stringMap.delete(attributeName);
                this.stringMapKeyRemoved(key, attributeName);
            }
            else {
                this.stringMap.set(attributeName, value);
            }
        }
    };
    StringMapObserver.prototype.stringMapKeyAdded = function (key, attributeName) {
        if (this.delegate.stringMapKeyAdded) {
            this.delegate.stringMapKeyAdded(key, attributeName);
        }
    };
    StringMapObserver.prototype.stringMapValueChanged = function (value, key) {
        if (this.delegate.stringMapValueChanged) {
            this.delegate.stringMapValueChanged(value, key);
        }
    };
    StringMapObserver.prototype.stringMapKeyRemoved = function (key, attributeName) {
        if (this.delegate.stringMapKeyRemoved) {
            this.delegate.stringMapKeyRemoved(key, attributeName);
        }
    };
    Object.defineProperty(StringMapObserver.prototype, "knownAttributeNames", {
        get: function () {
            return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StringMapObserver.prototype, "currentAttributeNames", {
        get: function () {
            return Array.from(this.element.attributes).map(function (attribute) { return attribute.name; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StringMapObserver.prototype, "recordedAttributeNames", {
        get: function () {
            return Array.from(this.stringMap.keys());
        },
        enumerable: false,
        configurable: true
    });
    return StringMapObserver;
}());

//# sourceMappingURL=string_map_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/set_operations.js
function add(map, key, value) {
    fetch(map, key).add(value);
}
function del(map, key, value) {
    fetch(map, key).delete(value);
    prune(map, key);
}
function fetch(map, key) {
    var values = map.get(key);
    if (!values) {
        values = new Set();
        map.set(key, values);
    }
    return values;
}
function prune(map, key) {
    var values = map.get(key);
    if (values != null && values.size == 0) {
        map.delete(key);
    }
}
//# sourceMappingURL=set_operations.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/multimap.js

var Multimap = /** @class */ (function () {
    function Multimap() {
        this.valuesByKey = new Map();
    }
    Object.defineProperty(Multimap.prototype, "values", {
        get: function () {
            var sets = Array.from(this.valuesByKey.values());
            return sets.reduce(function (values, set) { return values.concat(Array.from(set)); }, []);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Multimap.prototype, "size", {
        get: function () {
            var sets = Array.from(this.valuesByKey.values());
            return sets.reduce(function (size, set) { return size + set.size; }, 0);
        },
        enumerable: false,
        configurable: true
    });
    Multimap.prototype.add = function (key, value) {
        add(this.valuesByKey, key, value);
    };
    Multimap.prototype.delete = function (key, value) {
        del(this.valuesByKey, key, value);
    };
    Multimap.prototype.has = function (key, value) {
        var values = this.valuesByKey.get(key);
        return values != null && values.has(value);
    };
    Multimap.prototype.hasKey = function (key) {
        return this.valuesByKey.has(key);
    };
    Multimap.prototype.hasValue = function (value) {
        var sets = Array.from(this.valuesByKey.values());
        return sets.some(function (set) { return set.has(value); });
    };
    Multimap.prototype.getValuesForKey = function (key) {
        var values = this.valuesByKey.get(key);
        return values ? Array.from(values) : [];
    };
    Multimap.prototype.getKeysForValue = function (value) {
        return Array.from(this.valuesByKey)
            .filter(function (_a) {
            var key = _a[0], values = _a[1];
            return values.has(value);
        })
            .map(function (_a) {
            var key = _a[0], values = _a[1];
            return key;
        });
    };
    return Multimap;
}());

//# sourceMappingURL=multimap.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/indexed_multimap.js
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var IndexedMultimap = /** @class */ (function (_super) {
    __extends(IndexedMultimap, _super);
    function IndexedMultimap() {
        var _this = _super.call(this) || this;
        _this.keysByValue = new Map;
        return _this;
    }
    Object.defineProperty(IndexedMultimap.prototype, "values", {
        get: function () {
            return Array.from(this.keysByValue.keys());
        },
        enumerable: false,
        configurable: true
    });
    IndexedMultimap.prototype.add = function (key, value) {
        _super.prototype.add.call(this, key, value);
        add(this.keysByValue, value, key);
    };
    IndexedMultimap.prototype.delete = function (key, value) {
        _super.prototype.delete.call(this, key, value);
        del(this.keysByValue, value, key);
    };
    IndexedMultimap.prototype.hasValue = function (value) {
        return this.keysByValue.has(value);
    };
    IndexedMultimap.prototype.getKeysForValue = function (value) {
        var set = this.keysByValue.get(value);
        return set ? Array.from(set) : [];
    };
    return IndexedMultimap;
}(Multimap));

//# sourceMappingURL=indexed_multimap.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/multimap/dist/index.js



//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/token_list_observer.js


var TokenListObserver = /** @class */ (function () {
    function TokenListObserver(element, attributeName, delegate) {
        this.attributeObserver = new AttributeObserver(element, attributeName, this);
        this.delegate = delegate;
        this.tokensByElement = new Multimap;
    }
    Object.defineProperty(TokenListObserver.prototype, "started", {
        get: function () {
            return this.attributeObserver.started;
        },
        enumerable: false,
        configurable: true
    });
    TokenListObserver.prototype.start = function () {
        this.attributeObserver.start();
    };
    TokenListObserver.prototype.stop = function () {
        this.attributeObserver.stop();
    };
    TokenListObserver.prototype.refresh = function () {
        this.attributeObserver.refresh();
    };
    Object.defineProperty(TokenListObserver.prototype, "element", {
        get: function () {
            return this.attributeObserver.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TokenListObserver.prototype, "attributeName", {
        get: function () {
            return this.attributeObserver.attributeName;
        },
        enumerable: false,
        configurable: true
    });
    // Attribute observer delegate
    TokenListObserver.prototype.elementMatchedAttribute = function (element) {
        this.tokensMatched(this.readTokensForElement(element));
    };
    TokenListObserver.prototype.elementAttributeValueChanged = function (element) {
        var _a = this.refreshTokensForElement(element), unmatchedTokens = _a[0], matchedTokens = _a[1];
        this.tokensUnmatched(unmatchedTokens);
        this.tokensMatched(matchedTokens);
    };
    TokenListObserver.prototype.elementUnmatchedAttribute = function (element) {
        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    };
    TokenListObserver.prototype.tokensMatched = function (tokens) {
        var _this = this;
        tokens.forEach(function (token) { return _this.tokenMatched(token); });
    };
    TokenListObserver.prototype.tokensUnmatched = function (tokens) {
        var _this = this;
        tokens.forEach(function (token) { return _this.tokenUnmatched(token); });
    };
    TokenListObserver.prototype.tokenMatched = function (token) {
        this.delegate.tokenMatched(token);
        this.tokensByElement.add(token.element, token);
    };
    TokenListObserver.prototype.tokenUnmatched = function (token) {
        this.delegate.tokenUnmatched(token);
        this.tokensByElement.delete(token.element, token);
    };
    TokenListObserver.prototype.refreshTokensForElement = function (element) {
        var previousTokens = this.tokensByElement.getValuesForKey(element);
        var currentTokens = this.readTokensForElement(element);
        var firstDifferingIndex = zip(previousTokens, currentTokens)
            .findIndex(function (_a) {
            var previousToken = _a[0], currentToken = _a[1];
            return !tokensAreEqual(previousToken, currentToken);
        });
        if (firstDifferingIndex == -1) {
            return [[], []];
        }
        else {
            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
        }
    };
    TokenListObserver.prototype.readTokensForElement = function (element) {
        var attributeName = this.attributeName;
        var tokenString = element.getAttribute(attributeName) || "";
        return parseTokenString(tokenString, element, attributeName);
    };
    return TokenListObserver;
}());

function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter(function (content) { return content.length; })
        .map(function (content, index) { return ({ element: element, attributeName: attributeName, content: content, index: index }); });
}
function zip(left, right) {
    var length = Math.max(left.length, right.length);
    return Array.from({ length: length }, function (_, index) { return [left[index], right[index]]; });
}
function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
}
//# sourceMappingURL=token_list_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/value_list_observer.js

var ValueListObserver = /** @class */ (function () {
    function ValueListObserver(element, attributeName, delegate) {
        this.tokenListObserver = new TokenListObserver(element, attributeName, this);
        this.delegate = delegate;
        this.parseResultsByToken = new WeakMap;
        this.valuesByTokenByElement = new WeakMap;
    }
    Object.defineProperty(ValueListObserver.prototype, "started", {
        get: function () {
            return this.tokenListObserver.started;
        },
        enumerable: false,
        configurable: true
    });
    ValueListObserver.prototype.start = function () {
        this.tokenListObserver.start();
    };
    ValueListObserver.prototype.stop = function () {
        this.tokenListObserver.stop();
    };
    ValueListObserver.prototype.refresh = function () {
        this.tokenListObserver.refresh();
    };
    Object.defineProperty(ValueListObserver.prototype, "element", {
        get: function () {
            return this.tokenListObserver.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ValueListObserver.prototype, "attributeName", {
        get: function () {
            return this.tokenListObserver.attributeName;
        },
        enumerable: false,
        configurable: true
    });
    ValueListObserver.prototype.tokenMatched = function (token) {
        var element = token.element;
        var value = this.fetchParseResultForToken(token).value;
        if (value) {
            this.fetchValuesByTokenForElement(element).set(token, value);
            this.delegate.elementMatchedValue(element, value);
        }
    };
    ValueListObserver.prototype.tokenUnmatched = function (token) {
        var element = token.element;
        var value = this.fetchParseResultForToken(token).value;
        if (value) {
            this.fetchValuesByTokenForElement(element).delete(token);
            this.delegate.elementUnmatchedValue(element, value);
        }
    };
    ValueListObserver.prototype.fetchParseResultForToken = function (token) {
        var parseResult = this.parseResultsByToken.get(token);
        if (!parseResult) {
            parseResult = this.parseToken(token);
            this.parseResultsByToken.set(token, parseResult);
        }
        return parseResult;
    };
    ValueListObserver.prototype.fetchValuesByTokenForElement = function (element) {
        var valuesByToken = this.valuesByTokenByElement.get(element);
        if (!valuesByToken) {
            valuesByToken = new Map;
            this.valuesByTokenByElement.set(element, valuesByToken);
        }
        return valuesByToken;
    };
    ValueListObserver.prototype.parseToken = function (token) {
        try {
            var value = this.delegate.parseValueForToken(token);
            return { value: value };
        }
        catch (error) {
            return { error: error };
        }
    };
    return ValueListObserver;
}());

//# sourceMappingURL=value_list_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/mutation-observers/dist/index.js





//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/binding_observer.js



var BindingObserver = /** @class */ (function () {
    function BindingObserver(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.bindingsByAction = new Map;
    }
    BindingObserver.prototype.start = function () {
        if (!this.valueListObserver) {
            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
            this.valueListObserver.start();
        }
    };
    BindingObserver.prototype.stop = function () {
        if (this.valueListObserver) {
            this.valueListObserver.stop();
            delete this.valueListObserver;
            this.disconnectAllActions();
        }
    };
    Object.defineProperty(BindingObserver.prototype, "element", {
        get: function () {
            return this.context.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindingObserver.prototype, "identifier", {
        get: function () {
            return this.context.identifier;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindingObserver.prototype, "actionAttribute", {
        get: function () {
            return this.schema.actionAttribute;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindingObserver.prototype, "schema", {
        get: function () {
            return this.context.schema;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindingObserver.prototype, "bindings", {
        get: function () {
            return Array.from(this.bindingsByAction.values());
        },
        enumerable: false,
        configurable: true
    });
    BindingObserver.prototype.connectAction = function (action) {
        var binding = new Binding(this.context, action);
        this.bindingsByAction.set(action, binding);
        this.delegate.bindingConnected(binding);
    };
    BindingObserver.prototype.disconnectAction = function (action) {
        var binding = this.bindingsByAction.get(action);
        if (binding) {
            this.bindingsByAction.delete(action);
            this.delegate.bindingDisconnected(binding);
        }
    };
    BindingObserver.prototype.disconnectAllActions = function () {
        var _this = this;
        this.bindings.forEach(function (binding) { return _this.delegate.bindingDisconnected(binding); });
        this.bindingsByAction.clear();
    };
    // Value observer delegate
    BindingObserver.prototype.parseValueForToken = function (token) {
        var action = Action.forToken(token);
        if (action.identifier == this.identifier) {
            return action;
        }
    };
    BindingObserver.prototype.elementMatchedValue = function (element, action) {
        this.connectAction(action);
    };
    BindingObserver.prototype.elementUnmatchedValue = function (element, action) {
        this.disconnectAction(action);
    };
    return BindingObserver;
}());

//# sourceMappingURL=binding_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/value_observer.js

var ValueObserver = /** @class */ (function () {
    function ValueObserver(context, receiver) {
        this.context = context;
        this.receiver = receiver;
        this.stringMapObserver = new StringMapObserver(this.element, this);
        this.valueDescriptorMap = this.controller.valueDescriptorMap;
        this.invokeChangedCallbacksForDefaultValues();
    }
    ValueObserver.prototype.start = function () {
        this.stringMapObserver.start();
    };
    ValueObserver.prototype.stop = function () {
        this.stringMapObserver.stop();
    };
    Object.defineProperty(ValueObserver.prototype, "element", {
        get: function () {
            return this.context.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ValueObserver.prototype, "controller", {
        get: function () {
            return this.context.controller;
        },
        enumerable: false,
        configurable: true
    });
    // String map observer delegate
    ValueObserver.prototype.getStringMapKeyForAttribute = function (attributeName) {
        if (attributeName in this.valueDescriptorMap) {
            return this.valueDescriptorMap[attributeName].name;
        }
    };
    ValueObserver.prototype.stringMapValueChanged = function (attributeValue, name) {
        this.invokeChangedCallbackForValue(name);
    };
    ValueObserver.prototype.invokeChangedCallbacksForDefaultValues = function () {
        for (var _i = 0, _a = this.valueDescriptors; _i < _a.length; _i++) {
            var _b = _a[_i], key = _b.key, name_1 = _b.name, defaultValue = _b.defaultValue;
            if (defaultValue != undefined && !this.controller.data.has(key)) {
                this.invokeChangedCallbackForValue(name_1);
            }
        }
    };
    ValueObserver.prototype.invokeChangedCallbackForValue = function (name) {
        var methodName = name + "Changed";
        var method = this.receiver[methodName];
        if (typeof method == "function") {
            var value = this.receiver[name];
            method.call(this.receiver, value);
        }
    };
    Object.defineProperty(ValueObserver.prototype, "valueDescriptors", {
        get: function () {
            var valueDescriptorMap = this.valueDescriptorMap;
            return Object.keys(valueDescriptorMap).map(function (key) { return valueDescriptorMap[key]; });
        },
        enumerable: false,
        configurable: true
    });
    return ValueObserver;
}());

//# sourceMappingURL=value_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/context.js


var Context = /** @class */ (function () {
    function Context(module, scope) {
        this.module = module;
        this.scope = scope;
        this.controller = new module.controllerConstructor(this);
        this.bindingObserver = new BindingObserver(this, this.dispatcher);
        this.valueObserver = new ValueObserver(this, this.controller);
        try {
            this.controller.initialize();
        }
        catch (error) {
            this.handleError(error, "initializing controller");
        }
    }
    Context.prototype.connect = function () {
        this.bindingObserver.start();
        this.valueObserver.start();
        try {
            this.controller.connect();
        }
        catch (error) {
            this.handleError(error, "connecting controller");
        }
    };
    Context.prototype.disconnect = function () {
        try {
            this.controller.disconnect();
        }
        catch (error) {
            this.handleError(error, "disconnecting controller");
        }
        this.valueObserver.stop();
        this.bindingObserver.stop();
    };
    Object.defineProperty(Context.prototype, "application", {
        get: function () {
            return this.module.application;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "identifier", {
        get: function () {
            return this.module.identifier;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "schema", {
        get: function () {
            return this.application.schema;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "dispatcher", {
        get: function () {
            return this.application.dispatcher;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "element", {
        get: function () {
            return this.scope.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "parentElement", {
        get: function () {
            return this.element.parentElement;
        },
        enumerable: false,
        configurable: true
    });
    // Error handling
    Context.prototype.handleError = function (error, message, detail) {
        if (detail === void 0) { detail = {}; }
        var _a = this, identifier = _a.identifier, controller = _a.controller, element = _a.element;
        detail = Object.assign({ identifier: identifier, controller: controller, element: element }, detail);
        this.application.handleError(error, "Error " + message, detail);
    };
    return Context;
}());

//# sourceMappingURL=context.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/inheritable_statics.js
function readInheritableStaticArrayValues(constructor, propertyName) {
    var ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce(function (values, constructor) {
        getOwnStaticArrayValues(constructor, propertyName).forEach(function (name) { return values.add(name); });
        return values;
    }, new Set));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
    var ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce(function (pairs, constructor) {
        pairs.push.apply(pairs, getOwnStaticObjectPairs(constructor, propertyName));
        return pairs;
    }, []);
}
function getAncestorsForConstructor(constructor) {
    var ancestors = [];
    while (constructor) {
        ancestors.push(constructor);
        constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
    var definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
    var definition = constructor[propertyName];
    return definition ? Object.keys(definition).map(function (key) { return [key, definition[key]]; }) : [];
}
//# sourceMappingURL=inheritable_statics.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/blessing.js
var blessing_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

/** @hidden */
function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
    var shadowConstructor = extend(constructor);
    var shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
}
function getBlessedProperties(constructor) {
    var blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce(function (blessedProperties, blessing) {
        var properties = blessing(constructor);
        for (var key in properties) {
            var descriptor = blessedProperties[key] || {};
            blessedProperties[key] = Object.assign(descriptor, properties[key]);
        }
        return blessedProperties;
    }, {});
}
function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce(function (shadowProperties, key) {
        var _a;
        var descriptor = getShadowedDescriptor(prototype, properties, key);
        if (descriptor) {
            Object.assign(shadowProperties, (_a = {}, _a[key] = descriptor, _a));
        }
        return shadowProperties;
    }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
    var shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    var shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
        var descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
        if (shadowingDescriptor) {
            descriptor.get = shadowingDescriptor.get || descriptor.get;
            descriptor.set = shadowingDescriptor.set || descriptor.set;
        }
        return descriptor;
    }
}
var getOwnKeys = (function () {
    if (typeof Object.getOwnPropertySymbols == "function") {
        return function (object) { return __spreadArrays(Object.getOwnPropertyNames(object), Object.getOwnPropertySymbols(object)); };
    }
    else {
        return Object.getOwnPropertyNames;
    }
})();
var extend = (function () {
    function extendWithReflect(constructor) {
        function extended() {
            var _newTarget = this && this instanceof extended ? this.constructor : void 0;
            return Reflect.construct(constructor, arguments, _newTarget);
        }
        extended.prototype = Object.create(constructor.prototype, {
            constructor: { value: extended }
        });
        Reflect.setPrototypeOf(extended, constructor);
        return extended;
    }
    function testReflectExtension() {
        var a = function () { this.a.call(this); };
        var b = extendWithReflect(a);
        b.prototype.a = function () { };
        return new b;
    }
    try {
        testReflectExtension();
        return extendWithReflect;
    }
    catch (error) {
        return function (constructor) { return /** @class */ (function (_super) {
            blessing_extends(extended, _super);
            function extended() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return extended;
        }(constructor)); };
    }
})();
//# sourceMappingURL=blessing.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/definition.js

/** @hidden */
function blessDefinition(definition) {
    return {
        identifier: definition.identifier,
        controllerConstructor: bless(definition.controllerConstructor)
    };
}
//# sourceMappingURL=definition.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/module.js


var Module = /** @class */ (function () {
    function Module(application, definition) {
        this.application = application;
        this.definition = blessDefinition(definition);
        this.contextsByScope = new WeakMap;
        this.connectedContexts = new Set;
    }
    Object.defineProperty(Module.prototype, "identifier", {
        get: function () {
            return this.definition.identifier;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Module.prototype, "controllerConstructor", {
        get: function () {
            return this.definition.controllerConstructor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Module.prototype, "contexts", {
        get: function () {
            return Array.from(this.connectedContexts);
        },
        enumerable: false,
        configurable: true
    });
    Module.prototype.connectContextForScope = function (scope) {
        var context = this.fetchContextForScope(scope);
        this.connectedContexts.add(context);
        context.connect();
    };
    Module.prototype.disconnectContextForScope = function (scope) {
        var context = this.contextsByScope.get(scope);
        if (context) {
            this.connectedContexts.delete(context);
            context.disconnect();
        }
    };
    Module.prototype.fetchContextForScope = function (scope) {
        var context = this.contextsByScope.get(scope);
        if (!context) {
            context = new Context(this, scope);
            this.contextsByScope.set(scope, context);
        }
        return context;
    };
    return Module;
}());

//# sourceMappingURL=module.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/class_map.js
var ClassMap = /** @class */ (function () {
    function ClassMap(scope) {
        this.scope = scope;
    }
    ClassMap.prototype.has = function (name) {
        return this.data.has(this.getDataKey(name));
    };
    ClassMap.prototype.get = function (name) {
        return this.data.get(this.getDataKey(name));
    };
    ClassMap.prototype.getAttributeName = function (name) {
        return this.data.getAttributeNameForKey(this.getDataKey(name));
    };
    ClassMap.prototype.getDataKey = function (name) {
        return name + "-class";
    };
    Object.defineProperty(ClassMap.prototype, "data", {
        get: function () {
            return this.scope.data;
        },
        enumerable: false,
        configurable: true
    });
    return ClassMap;
}());

//# sourceMappingURL=class_map.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/string_helpers.js
function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, function (_, char) { return char.toUpperCase(); });
}
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
    return value.replace(/([A-Z])/g, function (_, char) { return "-" + char.toLowerCase(); });
}
//# sourceMappingURL=string_helpers.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/data_map.js

var DataMap = /** @class */ (function () {
    function DataMap(scope) {
        this.scope = scope;
    }
    Object.defineProperty(DataMap.prototype, "element", {
        get: function () {
            return this.scope.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DataMap.prototype, "identifier", {
        get: function () {
            return this.scope.identifier;
        },
        enumerable: false,
        configurable: true
    });
    DataMap.prototype.get = function (key) {
        var name = this.getAttributeNameForKey(key);
        return this.element.getAttribute(name);
    };
    DataMap.prototype.set = function (key, value) {
        var name = this.getAttributeNameForKey(key);
        this.element.setAttribute(name, value);
        return this.get(key);
    };
    DataMap.prototype.has = function (key) {
        var name = this.getAttributeNameForKey(key);
        return this.element.hasAttribute(name);
    };
    DataMap.prototype.delete = function (key) {
        if (this.has(key)) {
            var name_1 = this.getAttributeNameForKey(key);
            this.element.removeAttribute(name_1);
            return true;
        }
        else {
            return false;
        }
    };
    DataMap.prototype.getAttributeNameForKey = function (key) {
        return "data-" + this.identifier + "-" + dasherize(key);
    };
    return DataMap;
}());

//# sourceMappingURL=data_map.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/guide.js
var Guide = /** @class */ (function () {
    function Guide(logger) {
        this.warnedKeysByObject = new WeakMap;
        this.logger = logger;
    }
    Guide.prototype.warn = function (object, key, message) {
        var warnedKeys = this.warnedKeysByObject.get(object);
        if (!warnedKeys) {
            warnedKeys = new Set;
            this.warnedKeysByObject.set(object, warnedKeys);
        }
        if (!warnedKeys.has(key)) {
            warnedKeys.add(key);
            this.logger.warn(message, object);
        }
    };
    return Guide;
}());

//# sourceMappingURL=guide.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/selectors.js
/** @hidden */
function attributeValueContainsToken(attributeName, token) {
    return "[" + attributeName + "~=\"" + token + "\"]";
}
//# sourceMappingURL=selectors.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/target_set.js
var target_set_spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

var TargetSet = /** @class */ (function () {
    function TargetSet(scope) {
        this.scope = scope;
    }
    Object.defineProperty(TargetSet.prototype, "element", {
        get: function () {
            return this.scope.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TargetSet.prototype, "identifier", {
        get: function () {
            return this.scope.identifier;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TargetSet.prototype, "schema", {
        get: function () {
            return this.scope.schema;
        },
        enumerable: false,
        configurable: true
    });
    TargetSet.prototype.has = function (targetName) {
        return this.find(targetName) != null;
    };
    TargetSet.prototype.find = function () {
        var _this = this;
        var targetNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            targetNames[_i] = arguments[_i];
        }
        return targetNames.reduce(function (target, targetName) {
            return target
                || _this.findTarget(targetName)
                || _this.findLegacyTarget(targetName);
        }, undefined);
    };
    TargetSet.prototype.findAll = function () {
        var _this = this;
        var targetNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            targetNames[_i] = arguments[_i];
        }
        return targetNames.reduce(function (targets, targetName) { return target_set_spreadArrays(targets, _this.findAllTargets(targetName), _this.findAllLegacyTargets(targetName)); }, []);
    };
    TargetSet.prototype.findTarget = function (targetName) {
        var selector = this.getSelectorForTargetName(targetName);
        return this.scope.findElement(selector);
    };
    TargetSet.prototype.findAllTargets = function (targetName) {
        var selector = this.getSelectorForTargetName(targetName);
        return this.scope.findAllElements(selector);
    };
    TargetSet.prototype.getSelectorForTargetName = function (targetName) {
        var attributeName = "data-" + this.identifier + "-target";
        return attributeValueContainsToken(attributeName, targetName);
    };
    TargetSet.prototype.findLegacyTarget = function (targetName) {
        var selector = this.getLegacySelectorForTargetName(targetName);
        return this.deprecate(this.scope.findElement(selector), targetName);
    };
    TargetSet.prototype.findAllLegacyTargets = function (targetName) {
        var _this = this;
        var selector = this.getLegacySelectorForTargetName(targetName);
        return this.scope.findAllElements(selector).map(function (element) { return _this.deprecate(element, targetName); });
    };
    TargetSet.prototype.getLegacySelectorForTargetName = function (targetName) {
        var targetDescriptor = this.identifier + "." + targetName;
        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    };
    TargetSet.prototype.deprecate = function (element, targetName) {
        if (element) {
            var identifier = this.identifier;
            var attributeName = this.schema.targetAttribute;
            this.guide.warn(element, "target:" + targetName, "Please replace " + attributeName + "=\"" + identifier + "." + targetName + "\" with data-" + identifier + "-target=\"" + targetName + "\". " +
                ("The " + attributeName + " attribute is deprecated and will be removed in a future version of Stimulus."));
        }
        return element;
    };
    Object.defineProperty(TargetSet.prototype, "guide", {
        get: function () {
            return this.scope.guide;
        },
        enumerable: false,
        configurable: true
    });
    return TargetSet;
}());

//# sourceMappingURL=target_set.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/scope.js
var scope_spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};





var Scope = /** @class */ (function () {
    function Scope(schema, element, identifier, logger) {
        var _this = this;
        this.targets = new TargetSet(this);
        this.classes = new ClassMap(this);
        this.data = new DataMap(this);
        this.containsElement = function (element) {
            return element.closest(_this.controllerSelector) === _this.element;
        };
        this.schema = schema;
        this.element = element;
        this.identifier = identifier;
        this.guide = new Guide(logger);
    }
    Scope.prototype.findElement = function (selector) {
        return this.element.matches(selector)
            ? this.element
            : this.queryElements(selector).find(this.containsElement);
    };
    Scope.prototype.findAllElements = function (selector) {
        return scope_spreadArrays(this.element.matches(selector) ? [this.element] : [], this.queryElements(selector).filter(this.containsElement));
    };
    Scope.prototype.queryElements = function (selector) {
        return Array.from(this.element.querySelectorAll(selector));
    };
    Object.defineProperty(Scope.prototype, "controllerSelector", {
        get: function () {
            return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
        },
        enumerable: false,
        configurable: true
    });
    return Scope;
}());

//# sourceMappingURL=scope.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/scope_observer.js

var ScopeObserver = /** @class */ (function () {
    function ScopeObserver(element, schema, delegate) {
        this.element = element;
        this.schema = schema;
        this.delegate = delegate;
        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
        this.scopesByIdentifierByElement = new WeakMap;
        this.scopeReferenceCounts = new WeakMap;
    }
    ScopeObserver.prototype.start = function () {
        this.valueListObserver.start();
    };
    ScopeObserver.prototype.stop = function () {
        this.valueListObserver.stop();
    };
    Object.defineProperty(ScopeObserver.prototype, "controllerAttribute", {
        get: function () {
            return this.schema.controllerAttribute;
        },
        enumerable: false,
        configurable: true
    });
    // Value observer delegate
    /** @hidden */
    ScopeObserver.prototype.parseValueForToken = function (token) {
        var element = token.element, identifier = token.content;
        var scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
        var scope = scopesByIdentifier.get(identifier);
        if (!scope) {
            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
            scopesByIdentifier.set(identifier, scope);
        }
        return scope;
    };
    /** @hidden */
    ScopeObserver.prototype.elementMatchedValue = function (element, value) {
        var referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
        this.scopeReferenceCounts.set(value, referenceCount);
        if (referenceCount == 1) {
            this.delegate.scopeConnected(value);
        }
    };
    /** @hidden */
    ScopeObserver.prototype.elementUnmatchedValue = function (element, value) {
        var referenceCount = this.scopeReferenceCounts.get(value);
        if (referenceCount) {
            this.scopeReferenceCounts.set(value, referenceCount - 1);
            if (referenceCount == 1) {
                this.delegate.scopeDisconnected(value);
            }
        }
    };
    ScopeObserver.prototype.fetchScopesByIdentifierForElement = function (element) {
        var scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
        if (!scopesByIdentifier) {
            scopesByIdentifier = new Map;
            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
        }
        return scopesByIdentifier;
    };
    return ScopeObserver;
}());

//# sourceMappingURL=scope_observer.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/router.js




var Router = /** @class */ (function () {
    function Router(application) {
        this.application = application;
        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
        this.scopesByIdentifier = new Multimap;
        this.modulesByIdentifier = new Map;
    }
    Object.defineProperty(Router.prototype, "element", {
        get: function () {
            return this.application.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Router.prototype, "schema", {
        get: function () {
            return this.application.schema;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Router.prototype, "logger", {
        get: function () {
            return this.application.logger;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Router.prototype, "controllerAttribute", {
        get: function () {
            return this.schema.controllerAttribute;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Router.prototype, "modules", {
        get: function () {
            return Array.from(this.modulesByIdentifier.values());
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Router.prototype, "contexts", {
        get: function () {
            return this.modules.reduce(function (contexts, module) { return contexts.concat(module.contexts); }, []);
        },
        enumerable: false,
        configurable: true
    });
    Router.prototype.start = function () {
        this.scopeObserver.start();
    };
    Router.prototype.stop = function () {
        this.scopeObserver.stop();
    };
    Router.prototype.loadDefinition = function (definition) {
        this.unloadIdentifier(definition.identifier);
        var module = new Module(this.application, definition);
        this.connectModule(module);
    };
    Router.prototype.unloadIdentifier = function (identifier) {
        var module = this.modulesByIdentifier.get(identifier);
        if (module) {
            this.disconnectModule(module);
        }
    };
    Router.prototype.getContextForElementAndIdentifier = function (element, identifier) {
        var module = this.modulesByIdentifier.get(identifier);
        if (module) {
            return module.contexts.find(function (context) { return context.element == element; });
        }
    };
    // Error handler delegate
    /** @hidden */
    Router.prototype.handleError = function (error, message, detail) {
        this.application.handleError(error, message, detail);
    };
    // Scope observer delegate
    /** @hidden */
    Router.prototype.createScopeForElementAndIdentifier = function (element, identifier) {
        return new Scope(this.schema, element, identifier, this.logger);
    };
    /** @hidden */
    Router.prototype.scopeConnected = function (scope) {
        this.scopesByIdentifier.add(scope.identifier, scope);
        var module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.connectContextForScope(scope);
        }
    };
    /** @hidden */
    Router.prototype.scopeDisconnected = function (scope) {
        this.scopesByIdentifier.delete(scope.identifier, scope);
        var module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.disconnectContextForScope(scope);
        }
    };
    // Modules
    Router.prototype.connectModule = function (module) {
        this.modulesByIdentifier.set(module.identifier, module);
        var scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach(function (scope) { return module.connectContextForScope(scope); });
    };
    Router.prototype.disconnectModule = function (module) {
        this.modulesByIdentifier.delete(module.identifier);
        var scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach(function (scope) { return module.disconnectContextForScope(scope); });
    };
    return Router;
}());

//# sourceMappingURL=router.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/schema.js
var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target"
};
//# sourceMappingURL=schema.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/application.js
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var application_spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};



var Application = /** @class */ (function () {
    function Application(element, schema) {
        if (element === void 0) { element = document.documentElement; }
        if (schema === void 0) { schema = defaultSchema; }
        this.logger = console;
        this.element = element;
        this.schema = schema;
        this.dispatcher = new Dispatcher(this);
        this.router = new Router(this);
    }
    Application.start = function (element, schema) {
        var application = new Application(element, schema);
        application.start();
        return application;
    };
    Application.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, domReady()];
                    case 1:
                        _a.sent();
                        this.dispatcher.start();
                        this.router.start();
                        return [2 /*return*/];
                }
            });
        });
    };
    Application.prototype.stop = function () {
        this.dispatcher.stop();
        this.router.stop();
    };
    Application.prototype.register = function (identifier, controllerConstructor) {
        this.load({ identifier: identifier, controllerConstructor: controllerConstructor });
    };
    Application.prototype.load = function (head) {
        var _this = this;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var definitions = Array.isArray(head) ? head : application_spreadArrays([head], rest);
        definitions.forEach(function (definition) { return _this.router.loadDefinition(definition); });
    };
    Application.prototype.unload = function (head) {
        var _this = this;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var identifiers = Array.isArray(head) ? head : application_spreadArrays([head], rest);
        identifiers.forEach(function (identifier) { return _this.router.unloadIdentifier(identifier); });
    };
    Object.defineProperty(Application.prototype, "controllers", {
        // Controllers
        get: function () {
            return this.router.contexts.map(function (context) { return context.controller; });
        },
        enumerable: false,
        configurable: true
    });
    Application.prototype.getControllerForElementAndIdentifier = function (element, identifier) {
        var context = this.router.getContextForElementAndIdentifier(element, identifier);
        return context ? context.controller : null;
    };
    // Error handling
    Application.prototype.handleError = function (error, message, detail) {
        this.logger.error("%s\n\n%o\n\n%o", message, error, detail);
    };
    return Application;
}());

function domReady() {
    return new Promise(function (resolve) {
        if (document.readyState == "loading") {
            document.addEventListener("DOMContentLoaded", resolve);
        }
        else {
            resolve();
        }
    });
}
//# sourceMappingURL=application.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/class_properties.js


/** @hidden */
function ClassPropertiesBlessing(constructor) {
    var classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce(function (properties, classDefinition) {
        return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
}
function propertiesForClassDefinition(key) {
    var _a;
    var name = key + "Class";
    return _a = {},
        _a[name] = {
            get: function () {
                var classes = this.classes;
                if (classes.has(key)) {
                    return classes.get(key);
                }
                else {
                    var attribute = classes.getAttributeName(key);
                    throw new Error("Missing attribute \"" + attribute + "\"");
                }
            }
        },
        _a["has" + capitalize(name)] = {
            get: function () {
                return this.classes.has(key);
            }
        },
        _a;
}
//# sourceMappingURL=class_properties.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/target_properties.js


/** @hidden */
function TargetPropertiesBlessing(constructor) {
    var targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce(function (properties, targetDefinition) {
        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
}
function propertiesForTargetDefinition(name) {
    var _a;
    return _a = {},
        _a[name + "Target"] = {
            get: function () {
                var target = this.targets.find(name);
                if (target) {
                    return target;
                }
                else {
                    throw new Error("Missing target element \"" + this.identifier + "." + name + "\"");
                }
            }
        },
        _a[name + "Targets"] = {
            get: function () {
                return this.targets.findAll(name);
            }
        },
        _a["has" + capitalize(name) + "Target"] = {
            get: function () {
                return this.targets.has(name);
            }
        },
        _a;
}
//# sourceMappingURL=target_properties.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/value_properties.js


/** @hidden */
function ValuePropertiesBlessing(constructor) {
    var valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    var propertyDescriptorMap = {
        valueDescriptorMap: {
            get: function () {
                var _this = this;
                return valueDefinitionPairs.reduce(function (result, valueDefinitionPair) {
                    var _a;
                    var valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);
                    var attributeName = _this.data.getAttributeNameForKey(valueDescriptor.key);
                    return Object.assign(result, (_a = {}, _a[attributeName] = valueDescriptor, _a));
                }, {});
            }
        }
    };
    return valueDefinitionPairs.reduce(function (properties, valueDefinitionPair) {
        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
}
/** @hidden */
function propertiesForValueDefinitionPair(valueDefinitionPair) {
    var _a;
    var definition = parseValueDefinitionPair(valueDefinitionPair);
    var type = definition.type, key = definition.key, name = definition.name;
    var read = readers[type], write = writers[type] || writers.default;
    return _a = {},
        _a[name] = {
            get: function () {
                var value = this.data.get(key);
                if (value !== null) {
                    return read(value);
                }
                else {
                    return definition.defaultValue;
                }
            },
            set: function (value) {
                if (value === undefined) {
                    this.data.delete(key);
                }
                else {
                    this.data.set(key, write(value));
                }
            }
        },
        _a["has" + capitalize(name)] = {
            get: function () {
                return this.data.has(key);
            }
        },
        _a;
}
function parseValueDefinitionPair(_a) {
    var token = _a[0], typeConstant = _a[1];
    var type = parseValueTypeConstant(typeConstant);
    return valueDescriptorForTokenAndType(token, type);
}
function parseValueTypeConstant(typeConstant) {
    switch (typeConstant) {
        case Array: return "array";
        case Boolean: return "boolean";
        case Number: return "number";
        case Object: return "object";
        case String: return "string";
    }
    throw new Error("Unknown value type constant \"" + typeConstant + "\"");
}
function valueDescriptorForTokenAndType(token, type) {
    var key = dasherize(token) + "-value";
    return {
        type: type,
        key: key,
        name: camelize(key),
        get defaultValue() { return defaultValuesByType[type]; }
    };
}
var defaultValuesByType = {
    get array() { return []; },
    boolean: false,
    number: 0,
    get object() { return {}; },
    string: ""
};
var readers = {
    array: function (value) {
        var array = JSON.parse(value);
        if (!Array.isArray(array)) {
            throw new TypeError("Expected array");
        }
        return array;
    },
    boolean: function (value) {
        return !(value == "0" || value == "false");
    },
    number: function (value) {
        return parseFloat(value);
    },
    object: function (value) {
        var object = JSON.parse(value);
        if (object === null || typeof object != "object" || Array.isArray(object)) {
            throw new TypeError("Expected object");
        }
        return object;
    },
    string: function (value) {
        return value;
    }
};
var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
};
function writeJSON(value) {
    return JSON.stringify(value);
}
function writeString(value) {
    return "" + value;
}
//# sourceMappingURL=value_properties.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/controller.js



var Controller = /** @class */ (function () {
    function Controller(context) {
        this.context = context;
    }
    Object.defineProperty(Controller.prototype, "application", {
        get: function () {
            return this.context.application;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "scope", {
        get: function () {
            return this.context.scope;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "element", {
        get: function () {
            return this.scope.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "identifier", {
        get: function () {
            return this.scope.identifier;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "targets", {
        get: function () {
            return this.scope.targets;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "classes", {
        get: function () {
            return this.scope.classes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Controller.prototype, "data", {
        get: function () {
            return this.scope.data;
        },
        enumerable: false,
        configurable: true
    });
    Controller.prototype.initialize = function () {
        // Override in your subclass to set up initial controller state
    };
    Controller.prototype.connect = function () {
        // Override in your subclass to respond when the controller is connected to the DOM
    };
    Controller.prototype.disconnect = function () {
        // Override in your subclass to respond when the controller is disconnected from the DOM
    };
    Controller.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];
    Controller.targets = [];
    Controller.values = {};
    return Controller;
}());

//# sourceMappingURL=controller.js.map
;// CONCATENATED MODULE: ./node_modules/@stimulus/core/dist/index.js




//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/stimulus/index.js



/***/ }),

/***/ 470:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploaderController = exports.TooltipController = exports.setTooltipText = exports.setTooltipHtml = exports.TableController = exports.showPopover = exports.PopoverController = exports.BasePopoverController = exports.hidePopover = exports.detachPopover = exports.attachPopover = exports.TabListController = exports.showModal = exports.ModalController = exports.hideModal = exports.ExpandableController = void 0;
// export all controllers *with helpers* so they can be bulk re-exported by the package entry point
var s_expandable_control_1 = __webpack_require__(601);
Object.defineProperty(exports, "ExpandableController", ({ enumerable: true, get: function () { return s_expandable_control_1.ExpandableController; } }));
var s_modal_1 = __webpack_require__(181);
Object.defineProperty(exports, "hideModal", ({ enumerable: true, get: function () { return s_modal_1.hideModal; } }));
Object.defineProperty(exports, "ModalController", ({ enumerable: true, get: function () { return s_modal_1.ModalController; } }));
Object.defineProperty(exports, "showModal", ({ enumerable: true, get: function () { return s_modal_1.showModal; } }));
var s_navigation_tablist_1 = __webpack_require__(642);
Object.defineProperty(exports, "TabListController", ({ enumerable: true, get: function () { return s_navigation_tablist_1.TabListController; } }));
var s_popover_1 = __webpack_require__(388);
Object.defineProperty(exports, "attachPopover", ({ enumerable: true, get: function () { return s_popover_1.attachPopover; } }));
Object.defineProperty(exports, "detachPopover", ({ enumerable: true, get: function () { return s_popover_1.detachPopover; } }));
Object.defineProperty(exports, "hidePopover", ({ enumerable: true, get: function () { return s_popover_1.hidePopover; } }));
Object.defineProperty(exports, "BasePopoverController", ({ enumerable: true, get: function () { return s_popover_1.BasePopoverController; } }));
Object.defineProperty(exports, "PopoverController", ({ enumerable: true, get: function () { return s_popover_1.PopoverController; } }));
Object.defineProperty(exports, "showPopover", ({ enumerable: true, get: function () { return s_popover_1.showPopover; } }));
var s_table_1 = __webpack_require__(753);
Object.defineProperty(exports, "TableController", ({ enumerable: true, get: function () { return s_table_1.TableController; } }));
var s_tooltip_1 = __webpack_require__(355);
Object.defineProperty(exports, "setTooltipHtml", ({ enumerable: true, get: function () { return s_tooltip_1.setTooltipHtml; } }));
Object.defineProperty(exports, "setTooltipText", ({ enumerable: true, get: function () { return s_tooltip_1.setTooltipText; } }));
Object.defineProperty(exports, "TooltipController", ({ enumerable: true, get: function () { return s_tooltip_1.TooltipController; } }));
var s_uploader_1 = __webpack_require__(637);
Object.defineProperty(exports, "UploaderController", ({ enumerable: true, get: function () { return s_uploader_1.UploaderController; } }));


/***/ }),

/***/ 601:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExpandableController = void 0;
var Stacks = __webpack_require__(36);
// Radio buttons only trigger a change event when they're *checked*, but not when
// they're *unchecked*. Therefore, if we have an active `s-expandable-control` in
// the document, we listen for change events on *all* radio buttons and find any
// other radio buttons in the same `name` group, triggering a custom event on all
// of them so the controller can re-evaluate.
//
// We're keeping a count of how many of these controllers are connected to the DOM,
// so only have this global listener when we actually need it.
var RADIO_OFF_EVENT = "s-expandable-control:radio-off";
function globalChangeListener(e) {
    var target = e.target;
    if (!(target instanceof HTMLInputElement) || target.nodeName !== "INPUT" || target.type !== "radio") {
        return;
    }
    document.querySelectorAll('input[type="radio"][name="' + target.name + '"]')
        .forEach(function (other) {
        if (other === e.target) {
            return;
        }
        var customEvent;
        try {
            customEvent = new Event(RADIO_OFF_EVENT);
        }
        catch (ex) {
            // Internet Explorer
            customEvent = document.createEvent("Event");
            customEvent.initEvent(RADIO_OFF_EVENT, true, true);
        }
        other.dispatchEvent(customEvent);
    });
}
var refCount = 0;
function globalChangeListenerRequired(required) {
    if (required) {
        refCount++;
        if (refCount === 1) {
            document.body.addEventListener("change", globalChangeListener);
        }
    }
    else {
        refCount--;
        if (refCount === 0) {
            document.body.removeEventListener("change", globalChangeListener);
        }
    }
}
var ExpandableController = /** @class */ (function (_super) {
    __extends(ExpandableController, _super);
    function ExpandableController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.lastKeydownClickTimestamp = 0;
        return _this;
    }
    ExpandableController.prototype.initialize = function () {
        if (this.element.nodeName === "INPUT" && ["radio", "checkbox"].indexOf(this.element.type) >= 0) {
            this.isCollapsed = this._isCollapsedForCheckable.bind(this);
            this.events = ["change", RADIO_OFF_EVENT];
            this.isCheckable = true;
            this.isRadio = this.element.type === "radio";
        }
        else {
            this.isCollapsed = this._isCollapsedForClickable.bind(this);
            this.events = ["click", "keydown"];
        }
        this.listener = this.listener.bind(this);
    };
    ;
    // for non-checkable elements, the initial source of truth is the collapsed/expanded
    // state of the controlled element (unless the element doesn't exist)
    ExpandableController.prototype._isCollapsedForClickable = function () {
        var cc = this.controlledExpandables;
        // the element is considered collapsed if *any* target element is collapsed
        return cc.length > 0 ? !cc.every(function (element) { return element.classList.contains("is-expanded"); }) : this.element.getAttribute("aria-expanded") === "false";
    };
    ;
    // for checkable elements, the initial source of truth is the checked state
    ExpandableController.prototype._isCollapsedForCheckable = function () {
        return !this.element.checked;
    };
    ;
    Object.defineProperty(ExpandableController.prototype, "controlledExpandables", {
        get: function () {
            var attr = this.element.getAttribute("aria-controls");
            if (!attr) {
                throw "[aria-controls=\"targetId1 ... targetIdN\"] attribute required";
            }
            var result = attr.split(/\s+/g)
                .map(function (s) { return document.getElementById(s); })
                .filter(function (e) { return !!e; });
            if (!result.length) {
                throw "couldn't find controls";
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    ;
    ExpandableController.prototype._dispatchShowHideEvent = function (isShow) {
        this.triggerEvent(isShow ? "show" : "hide");
    };
    ;
    ExpandableController.prototype._toggleClass = function (doAdd) {
        if (!this.data.has("toggle-class")) {
            return;
        }
        var cl = this.element.classList;
        var toggleClass = this.data.get("toggle-class");
        if (!toggleClass) {
            throw "couldn't find toggle class";
        }
        toggleClass.split(/\s+/).forEach(function (cls) {
            cl.toggle(cls, !!doAdd);
        });
    };
    ;
    ExpandableController.prototype.listener = function (e) {
        var newCollapsed;
        if (this.isCheckable) {
            newCollapsed = !this.element.checked;
        }
        else {
            if (e.type == "keydown" && (e instanceof KeyboardEvent && e.keyCode != 13 && e.keyCode != 32)) {
                return;
            }
            if (e.target !== e.currentTarget && ["A", "BUTTON"].indexOf(e.target.nodeName) >= 0) {
                return;
            }
            e.preventDefault();
            // Prevent "click" events from toggling the expandable within 300ms of "keydown".
            // e.preventDefault() should have done the same, but https://bugzilla.mozilla.org/show_bug.cgi?id=1487102
            // doesn't guarantee it.
            if (e.type == "keydown") {
                this.lastKeydownClickTimestamp = Date.now();
            }
            else if (e.type == "click" && Date.now() - this.lastKeydownClickTimestamp < 300) {
                return;
            }
            newCollapsed = this.element.getAttribute("aria-expanded") === "true";
            if (e.type === "click") {
                this.element.blur();
            }
        }
        this.element.setAttribute("aria-expanded", newCollapsed ? "false" : "true");
        for (var _i = 0, _a = this.controlledExpandables; _i < _a.length; _i++) {
            var controlledElement = _a[_i];
            controlledElement.classList.toggle("is-expanded", !newCollapsed);
        }
        this._dispatchShowHideEvent(!newCollapsed);
        this._toggleClass(!newCollapsed);
    };
    ;
    ExpandableController.prototype.connect = function () {
        var _this = this;
        this.events.forEach(function (e) {
            _this.element.addEventListener(e, _this.listener.bind(_this));
        }, this);
        if (this.isRadio) {
            globalChangeListenerRequired(true);
        }
        // synchronize state -- in all cases, this means setting the correct `aria-expanded`
        // attribute; for checkable controls this also means setting the `is-collapsed` class.
        // Note: aria-expanded is currently an invalid attribute on radio elements
        // Support for aria-expanded is being debated by the W3C https://github.com/w3c/aria/issues/1404 as recently as June 2022
        if (!this.isRadio) {
            this.element.setAttribute("aria-expanded", this.isCollapsed() ? "false" : "true");
        }
        if (this.isCheckable) {
            var cc = this.controlledExpandables;
            if (cc.length) {
                var expected_1 = !this.isCollapsed();
                // if any element does not match the expected state, set them all to the expected state
                if (cc.some(function (element) { return element.classList.contains("is-expanded") !== expected_1; })) {
                    for (var _i = 0, _a = this.controlledExpandables; _i < _a.length; _i++) {
                        var controlledElement = _a[_i];
                        controlledElement.classList.toggle("is-expanded", expected_1);
                    }
                    this._dispatchShowHideEvent(expected_1);
                    this._toggleClass(expected_1);
                }
            }
        }
    };
    ;
    ExpandableController.prototype.disconnect = function () {
        var _this = this;
        this.events.forEach(function (e) {
            _this.element.removeEventListener(e, _this.listener.bind(_this));
        }, this);
        if (this.isRadio) {
            globalChangeListenerRequired(false);
        }
    };
    ;
    return ExpandableController;
}(Stacks.StacksController));
exports.ExpandableController = ExpandableController;


/***/ }),

/***/ 181:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hideModal = exports.showModal = exports.ModalController = void 0;
var Stacks = __webpack_require__(36);
var ModalController = /** @class */ (function (_super) {
    __extends(ModalController, _super);
    function ModalController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ModalController.prototype.connect = function () {
        this.validate();
    };
    /**
     * Disconnects all added event listeners on controller disconnect
     */
    ModalController.prototype.disconnect = function () {
        this.unbindDocumentEvents();
    };
    ;
    /**
     * Toggles the visibility of the modal
     */
    ModalController.prototype.toggle = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this._toggle(undefined, dispatcher);
    };
    /**
     * Shows the modal
     */
    ModalController.prototype.show = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this._toggle(true, dispatcher);
    };
    /**
     * Hides the modal
     */
    ModalController.prototype.hide = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this._toggle(false, dispatcher);
    };
    /**
     * Validates the modal settings and attempts to set necessary internal variables
     */
    ModalController.prototype.validate = function () {
        // check for returnElement support
        var returnElementSelector = this.data.get("return-element");
        if (returnElementSelector) {
            this.returnElement = document.querySelector(returnElementSelector);
            if (!this.returnElement) {
                throw "Unable to find element by return-element selector: " + returnElementSelector;
            }
        }
    };
    /**
     * Toggles the visibility of the modal element
     * @param show Optional parameter that force shows/hides the element or toggles it if left undefined
     */
    ModalController.prototype._toggle = function (show, dispatcher) {
        var _this = this;
        if (dispatcher === void 0) { dispatcher = null; }
        var toShow = show;
        var isVisible = this.modalTarget.getAttribute("aria-hidden") === "false";
        // if we're letting the class toggle, we need to figure out if the popover is visible manually
        if (typeof toShow === "undefined") {
            toShow = !isVisible;
        }
        // if the state matches the disired state, return without changing anything
        if ((toShow && isVisible) || (!toShow && !isVisible)) {
            return;
        }
        var dispatchingElement = this.getDispatcher(dispatcher);
        // show/hide events trigger before toggling the class
        var triggeredEvent = this.triggerEvent(toShow ? "show" : "hide", {
            returnElement: this.returnElement,
            dispatcher: this.getDispatcher(dispatchingElement)
        }, this.modalTarget);
        // if this pre-show/hide event was prevented, don't attempt to continue changing the modal state
        if (triggeredEvent.defaultPrevented) {
            return;
        }
        this.returnElement = triggeredEvent.detail.returnElement;
        this.modalTarget.setAttribute("aria-hidden", toShow ? "false" : "true");
        if (toShow) {
            this.bindDocumentEvents();
            this.focusInsideModal();
        }
        else {
            this.unbindDocumentEvents();
            this.focusReturnElement();
            this.removeModalOnHide();
        }
        // check for transitionend support
        var supportsTransitionEnd = (this.modalTarget).ontransitionend !== undefined;
        // shown/hidden events trigger after toggling the class
        if (supportsTransitionEnd) {
            // wait until after the modal finishes transitioning to fire the event
            this.modalTarget.addEventListener("transitionend", function () {
                //TODO this is firing waaay to soon?
                _this.triggerEvent(toShow ? "shown" : "hidden", {
                    dispatcher: dispatchingElement
                }, _this.modalTarget);
            }, { once: true });
        }
        else {
            this.triggerEvent(toShow ? "shown" : "hidden", {
                dispatcher: dispatchingElement
            }, this.modalTarget);
        }
    };
    /**
     * Listens for the s-modal:hidden event and focuses the returnElement when it is fired
     */
    ModalController.prototype.focusReturnElement = function () {
        var _this = this;
        if (!this.returnElement) {
            return;
        }
        this.modalTarget.addEventListener("s-modal:hidden", function () {
            // double check the element still exists when the event is called
            if (_this.returnElement && document.body.contains(_this.returnElement)) {
                _this.returnElement.focus();
            }
        }, { once: true });
    };
    /**
     * Remove the element on hide if the `remove-when-hidden` flag is set
     */
    ModalController.prototype.removeModalOnHide = function () {
        var _this = this;
        if (this.data.get("remove-when-hidden") !== "true") {
            return;
        }
        this.modalTarget.addEventListener("s-modal:hidden", function () {
            _this.element.remove();
        }, { once: true });
    };
    /**
     * Gets all elements within the modal that could receive keyboard focus.
     */
    ModalController.prototype.getAllTabbables = function () {
        return Array.from(this.modalTarget.querySelectorAll("[href], input, select, textarea, button, [tabindex]"))
            .filter(function (el) { return el.matches(":not([disabled]):not([tabindex='-1'])"); });
    };
    /**
     * Returns the first visible element in an array or `undefined` if no elements are visible.
     */
    ModalController.prototype.firstVisible = function (elements) {
        // https://stackoverflow.com/a/21696585
        return elements.find(function (el) { return el.offsetParent !== null; });
    };
    /**
     * Returns the last visible element in an array or `undefined` if no elements are visible.
     */
    ModalController.prototype.lastVisible = function (elements) {
        return this.firstVisible(__spreadArray([], elements, true).reverse());
    };
    /**
     * Attempts to shift keyboard focus into the modal.
     * If elements with `data-s-modal-target="initialFocus"` are present and visible, one of those will be selected.
     * Otherwise, the first visible focusable element will receive focus.
     */
    ModalController.prototype.focusInsideModal = function () {
        var _this = this;
        this.modalTarget.addEventListener("s-modal:shown", function () {
            var _a;
            var initialFocus = (_a = _this.firstVisible(_this.initialFocusTargets)) !== null && _a !== void 0 ? _a : _this.firstVisible(_this.getAllTabbables());
            initialFocus === null || initialFocus === void 0 ? void 0 : initialFocus.focus();
        }, { once: true });
    };
    /**
     * Returns keyboard focus to the modal if it has left or is about to leave.
     */
    ModalController.prototype.keepFocusWithinModal = function (e) {
        // If somehow the user has tabbed out of the modal or if focus started outside the modal, push them to the first item.
        if (!this.modalTarget.contains(e.target)) {
            var focusTarget = this.firstVisible(this.getAllTabbables());
            if (focusTarget) {
                e.preventDefault();
                focusTarget.focus();
            }
            return;
        }
        // If we observe a tab keydown and we're on an edge, cycle the focus to the other side.
        if (e.key === "Tab") {
            var tabbables = this.getAllTabbables();
            var firstTabbable = this.firstVisible(tabbables);
            var lastTabbable = this.lastVisible(tabbables);
            if (firstTabbable && lastTabbable) {
                if (firstTabbable === lastTabbable) {
                    e.preventDefault();
                    firstTabbable.focus();
                }
                else if (e.shiftKey && e.target === firstTabbable) {
                    e.preventDefault();
                    lastTabbable.focus();
                }
                else if (!e.shiftKey && e.target === lastTabbable) {
                    e.preventDefault();
                    firstTabbable.focus();
                }
            }
        }
    };
    /**
     * Binds global events to the document for hiding popovers on user interaction
     */
    ModalController.prototype.bindDocumentEvents = function () {
        // in order for removeEventListener to remove the right event, this bound function needs a constant reference
        this._boundClickFn = this._boundClickFn || this.hideOnOutsideClick.bind(this);
        this._boundKeypressFn = this._boundKeypressFn || this.hideOnEscapePress.bind(this);
        this._boundTabTrap = this._boundTabTrap || this.keepFocusWithinModal.bind(this);
        document.addEventListener("mousedown", this._boundClickFn);
        document.addEventListener("keyup", this._boundKeypressFn);
        document.addEventListener("keydown", this._boundTabTrap);
    };
    /**
     * Unbinds global events to the document for hiding popovers on user interaction
     */
    ModalController.prototype.unbindDocumentEvents = function () {
        document.removeEventListener("mousedown", this._boundClickFn);
        document.removeEventListener("keyup", this._boundKeypressFn);
        document.removeEventListener("keydown", this._boundTabTrap);
    };
    /**
     * Forces the popover to hide if a user clicks outside of it or its reference element
     */
    ModalController.prototype.hideOnOutsideClick = function (e) {
        var target = e.target;
        // check if the document was clicked inside either the toggle element or the modal itself
        // note: .contains also returns true if the node itself matches the target element
        if (!this.modalTarget.querySelector(".s-modal--dialog").contains(target) && document.body.contains(target)) {
            this._toggle(false, e);
        }
    };
    /**
     * Forces the popover to hide if the user presses escape while it, one of its childen, or the reference element are focused
     */
    ModalController.prototype.hideOnEscapePress = function (e) {
        // if the ESC key (27) wasn't pressed or if no popovers are showing, return
        if (e.which !== 27 || this.modalTarget.getAttribute("aria-hidden") === "true") {
            return;
        }
        this._toggle(false, e);
    };
    /**
     * Determines the correct dispatching element from a potential input
     * @param dispatcher The event or element to get the dispatcher from
     */
    ModalController.prototype.getDispatcher = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        if (dispatcher instanceof Event) {
            return dispatcher.target;
        }
        else if (dispatcher instanceof Element) {
            return dispatcher;
        }
        else {
            return this.element;
        }
    };
    ModalController.targets = ["modal", "initialFocus"];
    return ModalController;
}(Stacks.StacksController));
exports.ModalController = ModalController;
/**
 * Helper to manually show an s-modal element via external JS
 * @param element the element the `data-controller="s-modal"` attribute is on
 */
function showModal(element) {
    toggleModal(element, true);
}
exports.showModal = showModal;
/**
 * Helper to manually hide an s-modal element via external JS
 * @param element the element the `data-controller="s-modal"` attribute is on
 */
function hideModal(element) {
    toggleModal(element, false);
}
exports.hideModal = hideModal;
/**
 * Helper to manually show an s-modal element via external JS
 * @param element the element the `data-controller="s-modal"` attribute is on
 * @param show whether to force show/hide the modal; toggles the modal if left undefined
 */
function toggleModal(element, show) {
    var controller = Stacks.application.getControllerForElementAndIdentifier(element, "s-modal");
    if (!controller) {
        throw "Unable to get s-modal controller from element";
    }
    show ? controller.show() : controller.hide();
}


/***/ }),

/***/ 642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabListController = void 0;
var Stacks = __webpack_require__(36);
var TabListController = /** @class */ (function (_super) {
    __extends(TabListController, _super);
    function TabListController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TabListController.prototype.connect = function () {
        _super.prototype.connect.call(this);
        this.boundSelectTab = this.selectTab.bind(this);
        this.boundHandleKeydown = this.handleKeydown.bind(this);
        for (var _i = 0, _a = this.tabTargets; _i < _a.length; _i++) {
            var tab = _a[_i];
            tab.addEventListener("click", this.boundSelectTab);
            tab.addEventListener("keydown", this.boundHandleKeydown);
        }
    };
    TabListController.prototype.disconnect = function () {
        _super.prototype.disconnect.call(this);
        for (var _i = 0, _a = this.tabTargets; _i < _a.length; _i++) {
            var tab = _a[_i];
            tab.removeEventListener("click", this.boundSelectTab);
            tab.removeEventListener("keydown", this.boundHandleKeydown);
        }
    };
    Object.defineProperty(TabListController.prototype, "tabTargets", {
        /**
         * Gets all tabs within the controller.
         */
        get: function () {
            return Array.from(this.element.querySelectorAll("[role=tab]"));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Handles click events on individual tabs, causing them to be selected.
     */
    TabListController.prototype.selectTab = function (event) {
        this.switchToTab(event.currentTarget);
    };
    /**
     * Handles left and right arrow keydown events on individual tabs,
     * selecting the adjacent tab corresponding to the event.
     */
    TabListController.prototype.handleKeydown = function (event) {
        var _a;
        var tabElement = event.currentTarget;
        var tabs = this.tabTargets;
        var tabIndex = tabs.indexOf(tabElement);
        if (event.key === "ArrowRight") {
            tabIndex++;
        }
        else if (event.key === "ArrowLeft") {
            tabIndex--;
        }
        else {
            return;
        }
        // Use circular navigation when users go past the first or last tab.
        if (tabIndex < 0) {
            tabIndex = tabs.length - 1;
        }
        if (tabIndex >= tabs.length) {
            tabIndex = 0;
        }
        tabElement = tabs[tabIndex];
        this.switchToTab(tabElement);
        // Focus the newly selected tab so it can receive keyboard events.
        (_a = this.selectedTab) === null || _a === void 0 ? void 0 : _a.focus();
    };
    /**
     * Attempts to switch to a new tab, doing nothing if the tab is already selected or
     * the s-navigation-tablist:select event is prevented.
     */
    TabListController.prototype.switchToTab = function (newTab) {
        var oldTab = this.selectedTab;
        if (oldTab === newTab) {
            return;
        }
        if (this.triggerEvent("select", { oldTab: oldTab, newTab: newTab }).defaultPrevented) {
            return;
        }
        this.selectedTab = newTab;
        this.triggerEvent("selected", { oldTab: oldTab, newTab: newTab });
    };
    Object.defineProperty(TabListController.prototype, "selectedTab", {
        /**
         * Returns the currently selected tab or null if no tabs are selected.
         */
        get: function () {
            return this.tabTargets.find(function (e) { return e.getAttribute("aria-selected") === "true"; }) || null;
        },
        /**
         * Switches the tablist to the provided tab, updating the tabs and panels
         * to reflect the change.
         * @param selectedTab The tab to select. If `null` is provided or the element
         * is not a valid tab, all tabs will be unselected.
         */
        set: function (selectedTab) {
            for (var _i = 0, _a = this.tabTargets; _i < _a.length; _i++) {
                var tab = _a[_i];
                var panelId = tab.getAttribute('aria-controls');
                var panel = panelId ? document.getElementById(panelId) : null;
                if (tab === selectedTab) {
                    tab.classList.add('is-selected');
                    tab.setAttribute('aria-selected', 'true');
                    tab.removeAttribute('tabindex');
                    panel === null || panel === void 0 ? void 0 : panel.classList.remove('d-none');
                }
                else {
                    tab.classList.remove('is-selected');
                    tab.setAttribute('aria-selected', 'false');
                    tab.setAttribute('tabindex', '-1');
                    panel === null || panel === void 0 ? void 0 : panel.classList.add('d-none');
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    return TabListController;
}(Stacks.StacksController));
exports.TabListController = TabListController;


/***/ }),

/***/ 388:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detachPopover = exports.attachPopover = exports.hidePopover = exports.showPopover = exports.PopoverController = exports.BasePopoverController = void 0;
var core_1 = __webpack_require__(492);
var Stacks = __webpack_require__(36);
var BasePopoverController = /** @class */ (function (_super) {
    __extends(BasePopoverController, _super);
    function BasePopoverController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BasePopoverController.prototype, "isVisible", {
        /**
         * Returns true if the if the popover is currently visible.
         */
        get: function () {
            var popoverElement = this.popoverElement;
            return popoverElement ? popoverElement.classList.contains("is-visible") : false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePopoverController.prototype, "isInViewport", {
        /**
         * Gets whether the element is visible in the browser's viewport.
         */
        get: function () {
            var element = this.popoverElement;
            if (!this.isVisible || !element) {
                return false;
            }
            // From https://stackoverflow.com/a/5354536.  Theoretically, this could be calculated using Popper's detectOverflow function,
            // but it's unclear how to access that with our current configuration.
            var rect = element.getBoundingClientRect();
            var viewHeight = Math.max(document.documentElement.clientHeight, window.innerHeight);
            var viewWidth = Math.max(document.documentElement.clientWidth, window.innerWidth);
            return rect.bottom > 0 && rect.top < viewHeight && rect.right > 0 && rect.left < viewWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePopoverController.prototype, "shouldHideOnOutsideClick", {
        get: function () {
            var hideBehavior = this.data.get("hide-on-outside-click");
            switch (hideBehavior) {
                case "after-dismissal":
                case "never":
                    return false;
                case "if-in-viewport":
                    return this.isInViewport;
                default:
                    return true;
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Initializes and validates controller variables
     */
    BasePopoverController.prototype.connect = function () {
        _super.prototype.connect.call(this);
        this.validate();
        if (this.isVisible) {
            // just call initialize here, not show. This keeps already visible popovers from adding/firing document events
            this.initializePopper();
        }
        else if (this.data.get("auto-show") === "true") {
            this.show(null);
        }
        this.data.delete("auto-show");
    };
    /**
     * Cleans up popper.js elements and disconnects all added event listeners
     */
    BasePopoverController.prototype.disconnect = function () {
        this.hide();
        if (this.popper) {
            this.popper.destroy();
            // eslint-disable-next-line
            // @ts-ignore The operand of a 'delete' operator must be optional .ts(2790)
            delete this.popper;
        }
        _super.prototype.disconnect.call(this);
    };
    /**
     * Toggles the visibility of the popover
     */
    BasePopoverController.prototype.toggle = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this.isVisible ? this.hide(dispatcher) : this.show(dispatcher);
    };
    /**
     * Shows the popover if not already visible
     */
    BasePopoverController.prototype.show = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        if (this.isVisible) {
            return;
        }
        var dispatcherElement = this.getDispatcher(dispatcher);
        if (this.triggerEvent("show", {
            dispatcher: dispatcherElement
        }).defaultPrevented) {
            return;
        }
        if (!this.popper) {
            this.initializePopper();
        }
        this.popoverElement.classList.add("is-visible");
        // ensure the popper has been positioned correctly
        this.scheduleUpdate();
        this.shown(dispatcherElement);
    };
    /**
     * Hides the popover if not already hidden
     */
    BasePopoverController.prototype.hide = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        if (!this.isVisible) {
            return;
        }
        var dispatcherElement = this.getDispatcher(dispatcher);
        if (this.triggerEvent("hide", {
            dispatcher: dispatcherElement
        }).defaultPrevented) {
            return;
        }
        this.popoverElement.classList.remove("is-visible");
        if (this.popper) {
            // completely destroy the popper on hide; this is in line with Popper.js's performance recommendations
            this.popper.destroy();
            // eslint-disable-next-line
            // @ts-ignore The operand of a 'delete' operator must be optional .ts(2790)
            delete this.popper;
        }
        // on first interaction, hide-on-outside-click with value "after-dismissal" reverts to the default behavior
        if (this.data.get("hide-on-outside-click") === "after-dismissal") {
            this.data.delete("hide-on-outside-click");
        }
        this.hidden(dispatcherElement);
    };
    /**
     * Binds document events for this popover and fires the shown event
     */
    BasePopoverController.prototype.shown = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this.bindDocumentEvents();
        this.triggerEvent("shown", {
            dispatcher: dispatcher
        });
    };
    /**
     * Unbinds document events for this popover and fires the hidden event
     */
    BasePopoverController.prototype.hidden = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this.unbindDocumentEvents();
        this.triggerEvent("hidden", {
            dispatcher: dispatcher
        });
    };
    /**
     * Generates the popover if not found during initialization
     */
    BasePopoverController.prototype.generatePopover = function () {
        return null;
    };
    /**
     * Initializes the Popper for this instance
     */
    BasePopoverController.prototype.initializePopper = function () {
        this.popper = (0, core_1.createPopper)(this.referenceElement, this.popoverElement, {
            placement: this.data.get("placement") || "bottom",
            modifiers: [
                {
                    name: "offset",
                    options: {
                        offset: [0, 10], // The entire popover should be 10px away from the element
                    }
                },
                {
                    name: "arrow",
                    options: {
                        element: ".s-popover--arrow"
                    },
                },
            ]
        });
    };
    /**
     * Validates the popover settings and attempts to set necessary internal variables
     */
    BasePopoverController.prototype.validate = function () {
        var referenceSelector = this.data.get("reference-selector");
        this.referenceElement = this.element;
        // if there is an alternative reference selector and that element exists, use it (and throw if it isn't found)
        if (referenceSelector) {
            this.referenceElement = this.element.querySelector(referenceSelector);
            if (!this.referenceElement) {
                throw "Unable to find element by reference selector: " + referenceSelector;
            }
        }
        var popoverId = this.referenceElement.getAttribute(this.popoverSelectorAttribute);
        var popoverElement = null;
        // if the popover is named, attempt to fetch it (and throw an error if it doesn't exist)
        if (popoverId) {
            popoverElement = document.getElementById(popoverId);
            if (!popoverElement) {
                throw "[".concat(this.popoverSelectorAttribute, "=\"{POPOVER_ID}\"] required");
            }
        }
        // if the popover isn't named, attempt to generate it
        else {
            popoverElement = this.generatePopover();
        }
        if (!popoverElement) {
            throw "unable to find or generate popover element";
        }
        this.popoverElement = popoverElement;
    };
    /**
     * Determines the correct dispatching element from a potential input
     * @param dispatcher The event or element to get the dispatcher from
     */
    BasePopoverController.prototype.getDispatcher = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        if (dispatcher instanceof Event) {
            return dispatcher.target;
        }
        else if (dispatcher instanceof Element) {
            return dispatcher;
        }
        else {
            return this.element;
        }
    };
    /**
     * Schedules the popover to update on the next animation frame if visible
     */
    BasePopoverController.prototype.scheduleUpdate = function () {
        if (this.popper && this.isVisible) {
            void this.popper.update();
        }
    };
    return BasePopoverController;
}(Stacks.StacksController));
exports.BasePopoverController = BasePopoverController;
var PopoverController = /** @class */ (function (_super) {
    __extends(PopoverController, _super);
    function PopoverController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.popoverSelectorAttribute = "aria-controls";
        return _this;
    }
    /**
     * Toggles optional classes and accessibility attributes in addition to BasePopoverController.shown
     */
    PopoverController.prototype.shown = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this.toggleOptionalClasses(true);
        this.toggleAccessibilityAttributes(true);
        _super.prototype.shown.call(this, dispatcher);
    };
    /**
     * Toggles optional classes and accessibility attributes in addition to BasePopoverController.hidden
     */
    PopoverController.prototype.hidden = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        this.toggleOptionalClasses(false);
        this.toggleAccessibilityAttributes(false);
        _super.prototype.hidden.call(this, dispatcher);
    };
    /**
     * Initializes accessibility attributes in addition to BasePopoverController.connect
     */
    PopoverController.prototype.connect = function () {
        _super.prototype.connect.call(this);
        this.toggleAccessibilityAttributes();
    };
    /**
     * Binds global events to the document for hiding popovers on user interaction
     */
    PopoverController.prototype.bindDocumentEvents = function () {
        this.boundHideOnOutsideClick = this.boundHideOnOutsideClick || this.hideOnOutsideClick.bind(this);
        this.boundHideOnEscapePress = this.boundHideOnEscapePress || this.hideOnEscapePress.bind(this);
        document.addEventListener("mousedown", this.boundHideOnOutsideClick);
        document.addEventListener("keyup", this.boundHideOnEscapePress);
    };
    /**
     * Unbinds global events to the document for hiding popovers on user interaction
     */
    PopoverController.prototype.unbindDocumentEvents = function () {
        document.removeEventListener("mousedown", this.boundHideOnOutsideClick);
        document.removeEventListener("keyup", this.boundHideOnEscapePress);
    };
    /**
     * Forces the popover to hide if a user clicks outside of it or its reference element
     * @param {Event} e - The document click event
     */
    PopoverController.prototype.hideOnOutsideClick = function (e) {
        var target = e.target;
        // check if the document was clicked inside either the reference element or the popover itself
        // note: .contains also returns true if the node itself matches the target element
        if (this.shouldHideOnOutsideClick && !this.referenceElement.contains(target) && !this.popoverElement.contains(target) && document.body.contains(target)) {
            this.hide(e);
        }
    };
    ;
    /**
     * Forces the popover to hide if the user presses escape while it, one of its childen, or the reference element are focused
     * @param {Event} e - The document keyup event
     */
    PopoverController.prototype.hideOnEscapePress = function (e) {
        // if the ESC key (27) wasn't pressed or if no popovers are showing, return
        if (e.which !== 27 || !this.isVisible) {
            return;
        }
        // check if the target was inside the popover element and refocus the triggering element
        // note: .contains also returns true if the node itself matches the target element
        if (this.popoverElement.contains(e.target)) {
            this.referenceElement.focus();
        }
        this.hide(e);
    };
    ;
    /**
     * Toggles all classes on the originating element based on the `class-toggle` data
     * @param {boolean=} show - A boolean indicating whether this is being triggered by a show or hide.
     */
    PopoverController.prototype.toggleOptionalClasses = function (show) {
        if (!this.data.has("toggle-class")) {
            return;
        }
        var toggleClass = this.data.get("toggle-class") || "";
        var cl = this.referenceElement.classList;
        toggleClass.split(/\s+/).forEach(function (cls) {
            cl.toggle(cls, show);
        });
    };
    /**
     * Toggles accessibility attributes based on whether the popover is shown or not
     * @param {boolean=} show - A boolean indicating whether this is being triggered by a show or hide.
     */
    PopoverController.prototype.toggleAccessibilityAttributes = function (show) {
        var expandedValue = (show === null || show === void 0 ? void 0 : show.toString()) || this.referenceElement.ariaExpanded || "false";
        this.referenceElement.ariaExpanded = expandedValue;
        this.referenceElement.setAttribute("aria-expanded", expandedValue);
    };
    PopoverController.targets = [];
    return PopoverController;
}(BasePopoverController));
exports.PopoverController = PopoverController;
/**
 * Helper to manually show an s-popover element via external JS
 * @param element the element the `data-controller="s-popover"` attribute is on
 */
function showPopover(element) {
    var _a = getPopover(element), isPopover = _a.isPopover, controller = _a.controller;
    if (controller) {
        controller.show();
    }
    else if (isPopover) {
        element.setAttribute("data-s-popover-auto-show", "true");
    }
    else {
        throw "element does not have data-controller=\"s-popover\"";
    }
}
exports.showPopover = showPopover;
/**
 * Helper to manually hide an s-popover element via external JS
 * @param element the element the `data-controller="s-popover"` attribute is on
 */
function hidePopover(element) {
    var _a = getPopover(element), isPopover = _a.isPopover, controller = _a.controller, popover = _a.popover;
    if (controller) {
        controller.hide();
    }
    else if (isPopover) {
        element.removeAttribute("data-s-popover-auto-show");
        if (popover) {
            popover.classList.remove("is-visible");
        }
    }
    else {
        throw "element does not have data-controller=\"s-popover\"";
    }
}
exports.hidePopover = hidePopover;
/**
 * Attaches a popover to an element and performs additional configuration.
 * @param element the element that will receive the `data-controller="s-popover"` attribute.
 * @param popover an element with the `.s-popover` class or HTML string containing a single element with the `.s-popover` class.
 *                If the popover does not have a parent element, it will be inserted as a immediately after the reference element.
 * @param options an optional collection of options to use when configuring the popover.
 */
function attachPopover(element, popover, options) {
    var _a = getPopover(element), referenceElement = _a.referenceElement, existingPopover = _a.popover;
    if (existingPopover) {
        throw "element already has popover with id=\"".concat(existingPopover.id, "\"");
    }
    if (!referenceElement) {
        throw "element has invalid data-s-popover-reference-selector attribute";
    }
    if (typeof popover === 'string') {
        // eslint-disable-next-line no-unsanitized/method
        var elements = document.createRange().createContextualFragment(popover).children;
        if (elements.length !== 1) {
            throw "popover should contain a single element";
        }
        popover = elements[0];
    }
    var existingId = referenceElement.getAttribute("aria-controls");
    var popoverId = popover.id;
    if (!popover.classList.contains('s-popover')) {
        throw "popover should have the \"s-popover\" class but had class=\"".concat(popover.className, "\"");
    }
    if (existingId && existingId !== popoverId) {
        throw "element has aria-controls=\"".concat(existingId, "\" but popover has id=\"").concat(popoverId, "\"");
    }
    if (!popoverId) {
        popoverId = "--stacks-s-popover-" + Math.random().toString(36).substring(2, 10);
        popover.id = popoverId;
    }
    if (!existingId) {
        referenceElement.setAttribute("aria-controls", popoverId);
    }
    if (!popover.parentElement && element.parentElement) {
        referenceElement.insertAdjacentElement("afterend", popover);
    }
    toggleController(element, "s-popover", true);
    if (options) {
        if (options.toggleOnClick) {
            referenceElement.setAttribute("data-action", "click->s-popover#toggle");
        }
        if (options.placement) {
            element.setAttribute("data-s-popover-placement", options.placement);
        }
        if (options.autoShow) {
            element.setAttribute("data-s-popover-auto-show", "true");
        }
    }
}
exports.attachPopover = attachPopover;
/**
 * Removes the popover controller from an element and removes the popover from the DOM.
 * @param element the element that has the `data-controller="s-popover"` attribute.
 * @returns The popover that was attached to the element.
 */
function detachPopover(element) {
    var _a = getPopover(element), isPopover = _a.isPopover, controller = _a.controller, referenceElement = _a.referenceElement, popover = _a.popover;
    // Hide the popover so its events fire.
    controller === null || controller === void 0 ? void 0 : controller.hide();
    // Remove the popover if it exists
    popover === null || popover === void 0 ? void 0 : popover.remove();
    // Remove the popover controller and the aria-controls attributes.
    if (isPopover) {
        toggleController(element, "s-popover", false);
        if (referenceElement) {
            referenceElement.removeAttribute("aria-controls");
        }
    }
    return popover;
}
exports.detachPopover = detachPopover;
/**
 * Gets the current state of an element that may be or is intended to be an s-popover controller
 * so it can be configured either directly or via the DOM.
 * @param element An element that may have `data-controller="s-popover"`.
 */
function getPopover(element) {
    var _a;
    var isPopover = ((_a = element.getAttribute("data-controller")) === null || _a === void 0 ? void 0 : _a.includes("s-popover")) || false;
    var controller = Stacks.application.getControllerForElementAndIdentifier(element, "s-popover");
    var referenceSelector = element.getAttribute("data-s-popover-reference-selector");
    var referenceElement = referenceSelector ? element.querySelector(referenceSelector) : element;
    var popoverId = referenceElement ? referenceElement.getAttribute("aria-controls") : null;
    var popover = popoverId ? document.getElementById(popoverId) : null;
    return { isPopover: isPopover, controller: controller, referenceElement: referenceElement, popover: popover };
}
/**
 * Adds or removes the controller from an element's [data-controller] attribute without altering existing entries
 * @param el The element to alter
 * @param controllerName The name of the controller to add/remove
 * @param include Whether to add the controllerName value
 */
function toggleController(el, controllerName, include) {
    var _a;
    var controllers = new Set((_a = el.getAttribute('data-controller')) === null || _a === void 0 ? void 0 : _a.split(/\s+/));
    if (include) {
        controllers.add(controllerName);
    }
    else {
        controllers.delete(controllerName);
    }
    el.setAttribute('data-controller', Array.from(controllers).join(' '));
}


/***/ }),

/***/ 753:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableController = void 0;
var Stacks = __webpack_require__(36);
var TableController = /** @class */ (function (_super) {
    __extends(TableController, _super);
    function TableController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TableController.prototype.setCurrentSort = function (headElem, direction) {
        if (["asc", "desc", "none"].indexOf(direction) < 0) {
            throw "direction must be one of asc, desc, or none";
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var controller = this;
        this.columnTargets.forEach(function (target) {
            var isCurrrent = target === headElem;
            target.classList.toggle("is-sorted", isCurrrent && direction !== "none");
            target.querySelectorAll(".js-sorting-indicator").forEach(function (icon) {
                var visible = isCurrrent ? direction : "none";
                icon.classList.toggle("d-none", !icon.classList.contains("js-sorting-indicator-" + visible));
            });
            if (!isCurrrent || direction === "none") {
                controller.removeElementData(target, "sort-direction");
            }
            else {
                controller.setElementData(target, "sort-direction", direction);
            }
        });
    };
    ;
    TableController.prototype.sort = function (evt) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var controller = this;
        var colHead = evt.currentTarget;
        if (!(colHead instanceof HTMLTableCellElement)) {
            throw "invalid event target";
        }
        var table = this.element;
        var tbody = table.tBodies[0];
        // the column slot number of the clicked header
        var colno = getCellSlot(colHead);
        if (colno < 0) { // this shouldn't happen if the clicked element is actually a column head
            return;
        }
        // an index of the <tbody>, so we can find out for each row which <td> element is
        // in the same column slot as the header
        var slotIndex = buildIndex(tbody);
        // the default behavior when clicking a header is to sort by this column in ascending
        // direction, *unless* it is already sorted that way
        var direction = this.getElementData(colHead, "sort-direction") === "asc" ? -1 : 1;
        var rows = Array.from(table.tBodies[0].rows);
        // if this is still false after traversing the data, that means all values are integers (or empty)
        // and thus we'll sort numerically.
        var anyNonInt = false;
        // data will be a list of tuples [value, rowNum], where value is what we're sorting by
        var data = [];
        var firstBottomRow;
        rows.forEach(function (row, index) {
            var force = controller.getElementData(row, "sort-to");
            if (force === "top") {
                return; // rows not added to the list will automatically end up at the top
            }
            else if (force === "bottom") {
                if (!firstBottomRow) {
                    firstBottomRow = row;
                }
                return;
            }
            var cell = slotIndex[index][colno];
            if (!cell) {
                data.push(["", index]);
                return;
            }
            // unless the to-be-sorted-by value is explicitly provided on the element via this attribute,
            // the value we're using is the cell's text, trimmed of any whitespace
            var explicit = controller.getElementData(cell, "sort-val");
            var d = typeof explicit === "string" ? explicit : cell.textContent.trim();
            if ((d !== "") && ("".concat(parseInt(d, 10)) !== d)) {
                anyNonInt = true;
            }
            data.push([d, index]);
        });
        // If all values were integers (or empty cells), sort numerically, with empty cells treated as
        // having the lowest possible value (i.e. sorted to the top if ascending, bottom if descending)
        if (!anyNonInt) {
            data.forEach(function (tuple) {
                tuple[0] = tuple[0] === "" ? Number.MIN_VALUE : parseInt(tuple[0], 10);
            });
        }
        // We don't sort an array of <tr>, but instead an arrays of row *numbers*, because this way we
        // can enforce stable sorting, i.e. rows that compare equal are guaranteed to remain in the same
        // order (the JS standard does not gurantee this for sort()).
        data.sort(function (a, b) {
            // first compare the values (a[0])
            if (a[0] > b[0]) {
                return 1 * direction;
            }
            else if (a[0] < b[0]) {
                return -1 * direction;
            }
            else {
                // if the values are equal, compare the row numbers (a[1]) to guarantee stable sorting
                // (note that this comparison is independent of the sorting direction)
                return a[1] > b[1] ? 1 : -1;
            }
        });
        // this is the actual reordering of the table rows
        data.forEach(function (tup) {
            var row = rows[tup[1]];
            row.parentElement.removeChild(row);
            if (firstBottomRow) {
                tbody.insertBefore(row, firstBottomRow);
            }
            else {
                tbody.appendChild(row);
            }
        });
        // update the UI and set the `data-sort-direction` attribute if appropriate, so that the next click
        // will cause sorting in descending direction
        this.setCurrentSort(colHead, direction === 1 ? "asc" : "desc");
    };
    TableController.targets = ["column"];
    return TableController;
}(Stacks.StacksController));
exports.TableController = TableController;
function buildIndex(section) {
    var result = buildIndexOrGetCellSlot(section);
    if (!(result instanceof Array)) {
        throw "shouldn't happen";
    }
    return result;
}
function getCellSlot(cell) {
    if (!(cell.parentElement && cell.parentElement.parentElement instanceof HTMLTableSectionElement)) {
        throw "invalid table";
    }
    var result = buildIndexOrGetCellSlot(cell.parentElement.parentElement, cell);
    if (typeof result !== "number") {
        throw "shouldn't happen";
    }
    return result;
}
// Just because a <td> is the 4th *child* of its <tr> doesn't mean it belongs to the 4th *column*
// of the table. Previous cells may have a colspan; cells in previous rows may have a rowspan.
// Because we need to know which header cells and data cells belong together, we have to 1) find out
// which column number (or "slot" as we call it here) the header cell has, and 2) for each row find
// out which <td> cell corresponds to this slot (because those are the rows we're sorting by).
//
// That's what the following function does. If the second argument is not given, it returns an index
// of the table, which is an array of arrays. Each of the sub-arrays corresponds to a table row. The
// indices of the sub-array correspond to column slots; the values are the actual table cell elements.
// For example index[4][3] is the <td> or <th> in row 4, column 3 of the table section (<tbody> or <thead>).
// Note that this element is not necessarily even in the 4th (zero-based) <tr> -- if it has a rowSpan > 1,
// it may also be in a previous <tr>.
//
// If the second argument is given, it's a <td> or <th> that we're trying to find, and the algorithm
// stops as soon as it has found it and the function returns its slot number.
function buildIndexOrGetCellSlot(section, findCell) {
    var index = [];
    var curRow = section.children[0];
    // the elements of these two arrays are synchronized; the first array contains table cell elements,
    // the second one contains a number that indicates for how many more rows this elements will
    // exist (i.e. the value is initially one less than the cell's rowspan, and will be decreased for each row)
    var growing = [];
    var growingRowsLeft = [];
    // continue while we have actual <tr>'s left *or* we still have rowspan'ed elements that aren't done
    while (curRow || growingRowsLeft.some(function (e) { return e !== 0; })) {
        var curIndexRow = [];
        index.push(curIndexRow);
        var curSlot = 0;
        if (curRow) {
            for (var curCellInd = 0; curCellInd < curRow.children.length; curCellInd++) {
                while (growingRowsLeft[curSlot]) {
                    growingRowsLeft[curSlot]--;
                    curIndexRow[curSlot] = growing[curSlot];
                    curSlot++;
                }
                var cell = curRow.children[curCellInd];
                if (!(cell instanceof HTMLTableCellElement)) {
                    throw "invalid table";
                }
                if (getComputedStyle(cell).display === "none") {
                    continue;
                }
                if (cell === findCell) {
                    return curSlot;
                }
                var nextFreeSlot = curSlot + cell.colSpan;
                for (; curSlot < nextFreeSlot; curSlot++) {
                    growingRowsLeft[curSlot] = cell.rowSpan - 1; // if any of these is already growing, the table is broken -- no guarantees of anything
                    growing[curSlot] = cell;
                    curIndexRow[curSlot] = cell;
                }
            }
        }
        while (curSlot < growing.length) {
            if (growingRowsLeft[curSlot]) {
                growingRowsLeft[curSlot]--;
                curIndexRow[curSlot] = growing[curSlot];
            }
            curSlot++;
        }
        if (curRow) {
            curRow = curRow.nextElementSibling;
        }
    }
    return findCell ? -1 : index; /* if findCell was given but we end up here, that means it isn't in this section */
}


/***/ }),

/***/ 355:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setTooltipText = exports.setTooltipHtml = exports.TooltipController = void 0;
var Stacks = __webpack_require__(36);
var s_popover_1 = __webpack_require__(388);
var TooltipController = /** @class */ (function (_super) {
    __extends(TooltipController, _super);
    function TooltipController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.popoverSelectorAttribute = "aria-describedby";
        return _this;
    }
    /**
     * Binds mouseover and mouseout events in addition to BasePopoverController.connect
     */
    TooltipController.prototype.connect = function () {
        _super.prototype.connect.call(this);
        // Only bind to mouse events if the pointer device supports hover behavior.
        // Otherwise we run into issues with mobile browser showing popovers for
        // click events and not being able to hide them.
        if (window.matchMedia("(hover: hover)").matches) {
            this.bindMouseEvents();
        }
        this.bindKeyboardEvents();
    };
    /**
     * Unbinds mouse events in addition to BasePopoverController.disconnect
     */
    TooltipController.prototype.disconnect = function () {
        this.unbindKeyboardEvents();
        this.unbindMouseEvents();
        _super.prototype.disconnect.call(this);
    };
    /**
     * Attempts to show the tooltip popover so long as no other Stacks-managed popover is
     * present on the page.
     */
    TooltipController.prototype.show = function (dispatcher) {
        if (dispatcher === void 0) { dispatcher = null; }
        // check and see if this controller coexists with a popover
        var controller = Stacks.application.getControllerForElementAndIdentifier(this.element, "s-popover");
        // if the controller exists and already has a visible popover, don't show the tooltip
        if (controller && controller.isVisible) {
            return;
        }
        _super.prototype.show.call(this, dispatcher);
    };
    /**
     * Sets up a tooltip popover show after a delay.
     */
    TooltipController.prototype.scheduleShow = function (dispatcher) {
        var _this = this;
        if (dispatcher === void 0) { dispatcher = null; }
        window.clearTimeout(this.activeTimeout);
        this.activeTimeout = window.setTimeout(function () { return _this.show(dispatcher); }, 300);
    };
    /**
     * Cancels the scheduled tooltip popover display and hides it if already displayed
     */
    TooltipController.prototype.scheduleHide = function (dispatcher) {
        var _this = this;
        if (dispatcher === void 0) { dispatcher = null; }
        window.clearTimeout(this.activeTimeout);
        this.activeTimeout = window.setTimeout(function () { return _super.prototype.hide.call(_this, dispatcher); }, 100);
    };
    /**
     * Cancels the activeTimeout
     */
    TooltipController.prototype.clearActiveTimeout = function () {
        clearTimeout(this.activeTimeout);
    };
    /**
     * Applies data-s-tooltip-html-title and title attributes.
     */
    TooltipController.prototype.applyTitleAttributes = function () {
        var content;
        var htmlTitle = this.data.get("html-title");
        if (htmlTitle) {
            // eslint-disable-next-line no-unsanitized/method
            content = document.createRange().createContextualFragment(htmlTitle);
        }
        else {
            var plainTitle = this.element.getAttribute("title");
            if (plainTitle) {
                content = document.createTextNode(plainTitle);
            }
            else {
                return null;
            }
        }
        this.data.delete("html-title");
        this.element.removeAttribute("title");
        var popoverId = this.element.getAttribute("aria-describedby");
        if (!popoverId) {
            popoverId = TooltipController.generateId();
            this.element.setAttribute("aria-describedby", popoverId);
        }
        var popover = document.getElementById(popoverId);
        if (!popover) {
            popover = document.createElement("div");
            popover.id = popoverId;
            popover.className = "s-popover s-popover__tooltip";
            popover.setAttribute("role", "tooltip");
            var parentNode = this.element.parentNode;
            if (parentNode) {
                // insertBefore inserts at end if element.nextSibling is null.
                parentNode.insertBefore(popover, this.element.nextSibling);
            }
            else {
                document.body.appendChild(popover);
            }
        }
        var arrow = popover.querySelector(".s-popover--arrow");
        // clear and set the content of the popover
        popover.innerHTML = "";
        popover.appendChild(content);
        // create the arrow if necessary
        if (arrow) {
            popover.appendChild(arrow);
        }
        else {
            popover.insertAdjacentHTML("beforeend", "<div class=\"s-popover--arrow\"></div>");
        }
        this.scheduleUpdate();
        return popover;
    };
    /**
     * Automatically hides the tooltip popover when a Stacks popover is shown anywhere on
     * the page.
     */
    TooltipController.prototype.bindDocumentEvents = function () {
        this.boundHideIfWithin = this.boundHideIfWithin || this.hideIfWithin.bind(this);
        document.addEventListener("s-popover:shown", this.boundHideIfWithin);
    };
    /**
     * Unbinds all mouse events
     */
    TooltipController.prototype.unbindDocumentEvents = function () {
        document.removeEventListener("s-popover:shown", this.boundHideIfWithin);
    };
    /**
     * Attempts to generate a new tooltip popover from the title attribute if no popover
     * was present when requested, otherwise throws an error.
     */
    TooltipController.prototype.generatePopover = function () {
        return this.applyTitleAttributes();
    };
    /**
     * Hides the tooltip if is or is within the event's target.
     * @param event An event object from s-popover:shown
     */
    TooltipController.prototype.hideIfWithin = function (event) {
        if (event.target.contains(this.referenceElement)) {
            this.scheduleHide();
        }
    };
    TooltipController.prototype.hideOnEscapeKeyEvent = function (event) {
        if (event.key === "Escape") {
            this.scheduleHide();
        }
    };
    /**
     * Binds mouse events to show/hide on reference element hover
     */
    TooltipController.prototype.bindKeyboardEvents = function () {
        this.boundScheduleShow = this.boundScheduleShow || this.scheduleShow.bind(this);
        this.boundHide = this.boundHide || this.scheduleHide.bind(this);
        this.boundHideOnEscapeKeyEvent = this.boundHideOnEscapeKeyEvent || this.hideOnEscapeKeyEvent.bind(this);
        this.referenceElement.addEventListener("focus", this.boundScheduleShow);
        this.referenceElement.addEventListener("blur", this.boundHide);
        document.addEventListener("keyup", this.boundHideOnEscapeKeyEvent);
    };
    /**
     * Unbinds all mouse events
     */
    TooltipController.prototype.unbindKeyboardEvents = function () {
        this.referenceElement.removeEventListener("focus", this.boundScheduleShow);
        this.referenceElement.removeEventListener("blur", this.boundHide);
        document.removeEventListener("keyup", this.boundHideOnEscapeKeyEvent);
    };
    /**
     * Binds mouse events to show/hide on reference element hover
     */
    TooltipController.prototype.bindMouseEvents = function () {
        this.boundScheduleShow = this.boundScheduleShow || this.scheduleShow.bind(this);
        this.boundHide = this.boundHide || this.scheduleHide.bind(this);
        this.boundClearActiveTimeout = this.boundClearActiveTimeout || this.clearActiveTimeout.bind(this);
        this.referenceElement.addEventListener("mouseover", this.boundScheduleShow);
        this.referenceElement.addEventListener("mouseout", this.boundHide);
        this.popoverElement.addEventListener("mouseover", this.boundClearActiveTimeout);
        this.popoverElement.addEventListener("mouseout", this.boundHide);
    };
    /**
     * Unbinds all mouse events
     */
    TooltipController.prototype.unbindMouseEvents = function () {
        this.referenceElement.removeEventListener("mouseover", this.boundScheduleShow);
        this.referenceElement.removeEventListener("mouseout", this.boundHide);
        this.referenceElement.removeEventListener("focus", this.boundScheduleShow);
        this.referenceElement.removeEventListener("blur", this.boundHide);
        this.popoverElement.removeEventListener("mouseover", this.boundClearActiveTimeout);
        this.popoverElement.removeEventListener("mouseout", this.boundHide);
    };
    /**
     * Generates an ID for tooltips created with setTooltip.
     */
    TooltipController.generateId = function () {
        // generate a random number, then convert to a well formatted string
        return "--stacks-s-tooltip-" + Math.random().toString(36).substring(2, 10);
    };
    TooltipController.targets = [];
    return TooltipController;
}(s_popover_1.BasePopoverController));
exports.TooltipController = TooltipController;
/**
 * Adds or updates a Stacks tooltip on a given element, initializing the controller if necessary
 * @param element The element to add a tooltip to.
 * @param html An HTML string to populate the tooltip with.
 * @param options Options for rendering the tooltip.
 */
function setTooltipHtml(element, html, options) {
    element.setAttribute("data-s-tooltip-html-title", html);
    element.removeAttribute("title");
    applyOptionsAndTitleAttributes(element, options);
}
exports.setTooltipHtml = setTooltipHtml;
/**
 * Adds or updates a Stacks tooltip on a given element, initializing the controller if necessary
 * @param element The element to add a tooltip to.
 * @param text A plain text string to populate the tooltip with.
 * @param options Options for rendering the tooltip.
 */
function setTooltipText(element, text, options) {
    element.setAttribute("title", text);
    element.removeAttribute("data-s-tooltip-html-title");
    applyOptionsAndTitleAttributes(element, options);
}
exports.setTooltipText = setTooltipText;
/**
 * Shared helper for setTooltip* to initialize and set tooltip content
 * @param element The element to add a tooltip to.
 * @param options Options for rendering the tooltip.
 */
function applyOptionsAndTitleAttributes(element, options) {
    if (options && options.placement) {
        element.setAttribute("data-s-tooltip-placement", options.placement);
    }
    var controller = Stacks.application.getControllerForElementAndIdentifier(element, "s-tooltip");
    if (controller) {
        controller.applyTitleAttributes();
    }
    else {
        var dataController = element.getAttribute("data-controller");
        element.setAttribute("data-controller", "".concat(dataController ? dataController : "", " s-tooltip"));
    }
}


/***/ }),

/***/ 637:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UploaderController = void 0;
var Stacks = __webpack_require__(36);
;
var UploaderController = /** @class */ (function (_super) {
    __extends(UploaderController, _super);
    function UploaderController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    UploaderController.prototype.connect = function () {
        _super.prototype.connect.call(this);
        this.boundDragEnter = this.handleUploaderActive.bind(this, true);
        this.boundDragLeave = this.handleUploaderActive.bind(this, false);
        this.inputTarget.addEventListener("dragenter", this.boundDragEnter);
        this.inputTarget.addEventListener("dragleave", this.boundDragLeave);
    };
    UploaderController.prototype.disconnect = function () {
        this.inputTarget.removeEventListener("dragenter", this.boundDragEnter);
        this.inputTarget.removeEventListener("dragleave", this.boundDragLeave);
        _super.prototype.disconnect.call(this);
    };
    /**
     * Handles rendering the file preview state on input change
     */
    UploaderController.prototype.handleInput = function () {
        var _this = this;
        this.previewsTarget.innerHTML = "";
        if (!this.inputTarget.files) {
            return;
        }
        var count = this.inputTarget.files.length;
        this.getDataURLs(this.inputTarget.files, UploaderController.FILE_DISPLAY_LIMIT)
            .then(function (res) {
            _this.handleVisible(true);
            var hasMultipleFiles = res.length > 1;
            if (hasMultipleFiles) {
                var headingElement = document.createElement("div");
                headingElement.classList.add("s-uploader--previews-heading");
                headingElement.innerText = res.length < count ?
                    "Showing ".concat(res.length, " of ").concat(count, " files") : "".concat(count, " items");
                _this.previewsTarget.appendChild(headingElement);
                _this.previewsTarget.classList.add("has-multiple");
            }
            else {
                _this.previewsTarget.classList.remove("has-multiple");
            }
            res.forEach(function (file) { return _this.addFilePreview(file); });
            _this.handleUploaderActive(true);
        })
            // TODO consider rendering an error message
            .catch(function () { return null; });
    };
    /**
     * Resets the Uploader to initial state
     */
    UploaderController.prototype.reset = function () {
        this.inputTarget.value = '';
        this.previewsTarget.innerHTML = "";
        this.handleVisible(false);
    };
    /**
     * Set hide/show and disabled state on elements depending on preview state
     * @param  {boolean} shouldPreview - Uploader is entering a preview state
     */
    UploaderController.prototype.handleVisible = function (shouldPreview) {
        var scope = this.targets.scope;
        var hideElements = scope.findAllElements('[data-s-uploader-hide-on-input]');
        var showElements = scope.findAllElements('[data-s-uploader-show-on-input]');
        var enableElements = scope.findAllElements('[data-s-uploader-enable-on-input]');
        if (shouldPreview) {
            hideElements.forEach(function (el) {
                el.classList.add("d-none");
            });
            showElements.forEach(function (el) {
                el.classList.remove("d-none");
            });
            enableElements.forEach(function (el) {
                el.removeAttribute("disabled");
            });
        }
        else {
            hideElements.forEach(function (el) {
                el.classList.remove("d-none");
            });
            showElements.forEach(function (el) {
                el.classList.add("d-none");
            });
            enableElements.forEach(function (el) {
                el.setAttribute("disabled", "true");
            });
            this.handleUploaderActive(false);
        }
    };
    /**
     * Adds a DOM element to preview a selected file
     * @param  {FilePreview} file
     */
    UploaderController.prototype.addFilePreview = function (file) {
        if (!file) {
            return;
        }
        var previewElement = document.createElement("div");
        var thumbElement;
        if (file.type.match('image/*') && file.data) {
            thumbElement = document.createElement("img");
            thumbElement.src = file.data.toString();
            thumbElement.alt = file.name;
        }
        else {
            thumbElement = document.createElement("div");
            thumbElement.innerText = file.name;
        }
        thumbElement.classList.add("s-uploader--preview-thumbnail");
        previewElement.appendChild(thumbElement);
        previewElement.classList.add("s-uploader--preview");
        previewElement.setAttribute('data-filename', file.name);
        this.previewsTarget.appendChild(previewElement);
    };
    /**
     * Toggles display and disabled state for select elements on valid input
     * @param  {boolean} active - Uploader is in active state (typically on 'dragenter')
     */
    UploaderController.prototype.handleUploaderActive = function (active) {
        this.uploaderTarget.classList.toggle("is-active", active);
    };
    /**
     * Converts the file data into a data URL
     * @param  {File} file
     * @returns an object containing a FilePreview object
     */
    UploaderController.prototype.fileToDataURL = function (file) {
        var reader = new FileReader();
        var name = file.name, size = file.size, type = file.type;
        if (size < UploaderController.MAX_FILE_SIZE && type.indexOf("image") > -1) {
            return new Promise(function (resolve, reject) {
                reader.onload = function (evt) {
                    var _a;
                    var res = (_a = evt === null || evt === void 0 ? void 0 : evt.target) === null || _a === void 0 ? void 0 : _a.result;
                    if (res) {
                        resolve({ data: res, name: name, type: type });
                    }
                    else {
                        reject();
                    }
                };
                reader.readAsDataURL(file);
            });
        }
        else {
            return Promise.resolve({ name: name, type: type });
        }
    };
    /**
     * Gets an array of FilePreviews from a FileList
     * @param  {FileList|[]} files
     * @returns an array of FilePreview objects from a FileList
     */
    UploaderController.prototype.getDataURLs = function (files, limit) {
        var _this = this;
        var promises = Array.from(files)
            .slice(0, Math.min(limit, files.length))
            .map(function (f) { return _this.fileToDataURL(f); });
        return Promise.all(promises);
    };
    UploaderController.targets = ["input", "previews", "uploader"];
    UploaderController.FILE_DISPLAY_LIMIT = 10;
    UploaderController.MAX_FILE_SIZE = 1024 * 1024 * 10; // 10 MB
    return UploaderController;
}(Stacks.StacksController));
exports.UploaderController = UploaderController;
;


/***/ }),

/***/ 603:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(708);
var controllers_1 = __webpack_require__(470);
var stacks_1 = __webpack_require__(36);
// register all built-in controllers
stacks_1.application.register("s-expandable-control", controllers_1.ExpandableController);
stacks_1.application.register("s-modal", controllers_1.ModalController);
stacks_1.application.register("s-navigation-tablist", controllers_1.TabListController);
stacks_1.application.register("s-popover", controllers_1.PopoverController);
stacks_1.application.register("s-table", controllers_1.TableController);
stacks_1.application.register("s-tooltip", controllers_1.TooltipController);
stacks_1.application.register("s-uploader", controllers_1.UploaderController);
// finalize the application to guard our controller namespace
stacks_1.StacksApplication.finalize();
// export all controllers w/ helpers
__exportStar(__webpack_require__(470), exports);
// export the entirety of the contents of stacks.ts
__exportStar(__webpack_require__(36), exports);


/***/ }),

/***/ 36:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addController = exports.createController = exports.StacksController = exports.application = exports.StacksApplication = void 0;
var Stimulus = __webpack_require__(931);
var StacksApplication = /** @class */ (function (_super) {
    __extends(StacksApplication, _super);
    function StacksApplication() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StacksApplication.prototype.load = function (head) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var definitions = Array.isArray(head) ? head : __spreadArray([head], rest, true);
        for (var _a = 0, definitions_1 = definitions; _a < definitions_1.length; _a++) {
            var definition = definitions_1[_a];
            var hasPrefix = /^s-/.test(definition.identifier);
            if (StacksApplication._initializing && !hasPrefix) {
                throw "Stacks-created Stimulus controller names must start with \"s-\".";
            }
            if (!StacksApplication._initializing && hasPrefix) {
                throw "The \"s-\" prefix on Stimulus controller names is reserved for Stacks-created controllers.";
            }
        }
        _super.prototype.load.call(this, definitions);
    };
    StacksApplication.start = function (element, schema) {
        var application = new StacksApplication(element, schema);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        application.start();
        return application;
    };
    StacksApplication.finalize = function () {
        StacksApplication._initializing = false;
    };
    StacksApplication._initializing = true;
    return StacksApplication;
}(Stimulus.Application));
exports.StacksApplication = StacksApplication;
exports.application = StacksApplication.start();
var StacksController = /** @class */ (function (_super) {
    __extends(StacksController, _super);
    function StacksController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StacksController.prototype.getElementData = function (element, key) {
        return element.getAttribute("data-" + this.identifier + "-" + key);
    };
    ;
    StacksController.prototype.setElementData = function (element, key, value) {
        element.setAttribute("data-" + this.identifier + "-" + key, value);
    };
    ;
    StacksController.prototype.removeElementData = function (element, key) {
        element.removeAttribute("data-" + this.identifier + "-" + key);
    };
    ;
    StacksController.prototype.triggerEvent = function (eventName, detail, optionalElement) {
        var namespacedName = this.identifier + ":" + eventName;
        var event;
        try {
            event = new CustomEvent(namespacedName, { bubbles: true, cancelable: true, detail: detail });
        }
        catch (ex) {
            // Internet Explorer
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            event = document.createEvent("CustomEvent");
            event.initCustomEvent(namespacedName, true, true, detail);
        }
        (optionalElement || this.element).dispatchEvent(event);
        return event;
    };
    ;
    return StacksController;
}(Stimulus.Controller));
exports.StacksController = StacksController;
function createController(controllerDefinition) {
    var _a;
    // eslint-disable-next-line no-prototype-builtins
    var Controller = controllerDefinition.hasOwnProperty("targets")
        ? (_a = /** @class */ (function (_super) {
                __extends(Controller, _super);
                function Controller() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return Controller;
            }(StacksController)),
            _a.targets = controllerDefinition.targets,
            _a) : /** @class */ (function (_super) {
        __extends(Controller, _super);
        function Controller() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Controller;
    }(StacksController));
    for (var prop in controllerDefinition) {
        // eslint-disable-next-line no-prototype-builtins
        if (prop !== "targets" && controllerDefinition.hasOwnProperty(prop)) {
            Object.defineProperty(Controller.prototype, prop, Object.getOwnPropertyDescriptor(controllerDefinition, prop));
        }
    }
    return Controller;
}
exports.createController = createController;
function addController(name, controller) {
    exports.application.register(name, createController(controller));
}
exports.addController = addController;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(603);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});