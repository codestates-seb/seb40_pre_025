var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Plugin, TextSelection, } from "prosemirror-state";
import { Decoration, DecorationSet } from "prosemirror-view";
import { StatefulPlugin } from "./plugin-extensions";
import { escapeHTML, generateRandomId } from "../utils";
import { _t } from "../localization";
import { ManagedInterfaceKey, PluginInterfaceView } from "./interface-manager";
/**
 * Default image upload callback that posts to `/image/upload`,
 * expecting a json response like `{ UploadedImage: "https://www.example.com/path/to/file" }`
 * and returns `UploadedImage`'s value
 * @param file The file to upload
 */
export function defaultImageUploadHandler(file) {
    return __awaiter(this, void 0, void 0, function* () {
        const formData = new FormData();
        formData.append("file", file);
        const response = yield fetch("/image/upload", {
            method: "POST",
            cache: "no-cache",
            body: formData,
        });
        if (!response.ok) {
            throw Error(`Failed to upload image: ${response.status} - ${response.statusText}`);
        }
        const json = (yield response.json());
        return json.UploadedImage;
    });
}
var ValidationResult;
(function (ValidationResult) {
    ValidationResult[ValidationResult["Ok"] = 0] = "Ok";
    ValidationResult[ValidationResult["FileTooLarge"] = 1] = "FileTooLarge";
    ValidationResult[ValidationResult["InvalidFileType"] = 2] = "InvalidFileType";
})(ValidationResult || (ValidationResult = {}));
export class ImageUploader extends PluginInterfaceView {
    constructor(view, uploadOptions, validateLink, addTransactionDispatcher) {
        var _a, _b;
        super(INTERFACE_KEY);
        this.image = null;
        const randomId = generateRandomId();
        this.isVisible = false;
        this.uploadOptions = uploadOptions;
        this.validateLink = validateLink;
        this.addTransactionDispatcher = addTransactionDispatcher;
        this.uploadContainer = document.createElement("div");
        this.uploadContainer.className =
            "mt6 bt bb bc-black-400 js-image-uploader";
        this.uploadField = document.createElement("input");
        this.uploadField.type = "file";
        this.uploadField.className = "js-image-uploader-input v-visible-sr";
        this.uploadField.accept = "image/*";
        this.uploadField.multiple = false;
        this.uploadField.id = "fileUpload" + randomId;
        // TODO i18n
        this.uploadContainer.innerHTML = escapeHTML `
            <div class="fs-body2 p12 pb0 js-cta-container">
                <label for="${this.uploadField.id}" class="d-inline-flex f:outline-ring s-link js-browse-button" role="button" aria-controls="image-preview-${randomId}">
                    Browse
                </label>, drag & drop<span class="js-external-url-trigger-container d-none">, <button type="button" class="s-btn s-btn__link js-external-url-trigger">enter a link</button></span>, or paste an image <span class="fc-light fs-caption">Max size 2 MiB</span>
            </div>

            <div class="js-external-url-input-container p12 d-none">
                <div class="d-flex fd-row ai-center sm:fd-column sm:ai-start">
                    <label class="d-block s-label ws-nowrap mr4" for="external-url-input-${randomId}">
                        External url
                    </label>
                    <input id="external-url-input-${randomId}" type="text" class="s-input js-external-url-input" placeholder="https://example.com/img.png" />
                </div>
            </div>

            <div id="image-preview-${randomId}" class="js-image-preview wmx100 pt12 px12 d-none"></div>
            <aside class="s-notice s-notice__warning d-none m8 js-validation-message" role="status" aria-hidden="true"></aside>

            <div class="d-flex jc-space-between ai-center p12 sm:fd-column sm:ai-start sm:g16">
                <div>
                    <button class="s-btn s-btn__primary ws-nowrap mr8 js-add-image" type="button" disabled>Add image</button>
                    <button class="s-btn ws-nowrap js-cancel-button" type="button">Cancel</button>
                </div>
                <div class="d-flex fd-column fs-caption fc-black-300 s-anchors s-anchors__muted">
                    <div class="js-branding-html"></div>
                    <div class="js-content-policy-html"></div>
                </div>
            </div>
        `;
        // add in the uploadField right after the first child element
        this.uploadContainer
            .querySelector(`.js-browse-button`)
            .appendChild(this.uploadField);
        // XSS "safe": this html is passed in via the editor options; it is not our job to sanitize it
        // eslint-disable-next-line no-unsanitized/property
        this.uploadContainer.querySelector(".js-branding-html").innerHTML =
            (_a = this.uploadOptions) === null || _a === void 0 ? void 0 : _a.brandingHtml;
        // XSS "safe": this html is passed in via the editor options; it is not our job to sanitize it
        // eslint-disable-next-line no-unsanitized/property
        this.uploadContainer.querySelector(".js-content-policy-html").innerHTML = (_b = this.uploadOptions) === null || _b === void 0 ? void 0 : _b.contentPolicyHtml;
        this.uploadField.addEventListener("change", () => {
            this.handleFileSelection(view);
        });
        this.uploadContainer.addEventListener("dragenter", this.highlightDropArea.bind(this));
        this.uploadContainer.addEventListener("dragover", this.highlightDropArea.bind(this));
        // we need this handler on top of the plugin's handleDrop() to make
        // sure we're handling drop events on the upload container itself properly
        this.uploadContainer.addEventListener("drop", (event) => {
            this.unhighlightDropArea(event);
            this.handleDrop(event, view);
        });
        // we need this handler on top of the plugin's handlePaste() to make
        // sure we're handling paste events on the upload container itself properly
        this.uploadContainer.addEventListener("paste", (event) => {
            this.handlePaste(event, view);
        });
        this.uploadContainer.addEventListener("dragleave", this.unhighlightDropArea.bind(this));
        this.uploadContainer
            .querySelector(".js-cancel-button")
            .addEventListener("click", () => {
            const tr = this.tryHideInterfaceTr(view.state);
            if (tr) {
                view.dispatch(tr);
            }
        });
        this.uploadContainer
            .querySelector(".js-add-image")
            .addEventListener("click", (e) => this.handleUploadTrigger(e, this.image, view));
        if (this.uploadOptions.allowExternalUrls) {
            this.uploadContainer
                .querySelector(".js-external-url-trigger-container")
                .classList.remove("d-none");
            this.uploadContainer
                .querySelector(".js-external-url-trigger")
                .addEventListener("click", () => {
                this.toggleExternalUrlInput(true);
            });
            this.uploadContainer
                .querySelector(".js-external-url-input")
                .addEventListener("input", (e) => {
                this.validateExternalUrl(e.target.value);
            });
        }
    }
    highlightDropArea(event) {
        this.uploadContainer.classList.add("bs-ring");
        this.uploadContainer.classList.add("bc-blue-300");
        event.preventDefault();
        event.stopPropagation();
    }
    unhighlightDropArea(event) {
        this.uploadContainer.classList.remove("bs-ring");
        this.uploadContainer.classList.remove("bc-blue-300");
        event.preventDefault();
        event.stopPropagation();
    }
    handleFileSelection(view) {
        this.resetImagePreview();
        const files = this.uploadField.files;
        if (view.state.selection.$from.parent.inlineContent && files.length) {
            void this.showImagePreview(files[0]);
        }
    }
    handleDrop(event, view) {
        this.resetImagePreview();
        const files = event.dataTransfer.files;
        if (view.state.selection.$from.parent.inlineContent && files.length) {
            void this.showImagePreview(files[0]);
        }
    }
    handlePaste(event, view) {
        this.resetImagePreview();
        const files = event.clipboardData.files;
        if (view.state.selection.$from.parent.inlineContent && files.length) {
            void this.showImagePreview(files[0]);
        }
    }
    validateImage(image) {
        const validTypes = ["image/jpeg", "image/png", "image/gif"];
        const sizeLimit = 0x200000; // 2 MiB
        if (validTypes.indexOf(image.type) === -1) {
            return ValidationResult.InvalidFileType;
        }
        if (image.size >= sizeLimit) {
            return ValidationResult.FileTooLarge;
        }
        return ValidationResult.Ok;
    }
    showValidationError(errorMessage, level = "warning") {
        this.uploadField.value = null;
        const validationElement = this.uploadContainer.querySelector(".js-validation-message");
        if (level === "warning") {
            validationElement.classList.remove("s-notice__danger");
            validationElement.classList.add("s-notice__warning");
        }
        else {
            validationElement.classList.remove("s-notice__warning");
            validationElement.classList.add("s-notice__danger");
        }
        validationElement.classList.remove("d-none");
        validationElement.textContent = errorMessage;
    }
    hideValidationError() {
        const validationElement = this.uploadContainer.querySelector(".js-validation-message");
        validationElement.classList.add("d-none");
        validationElement.classList.remove("s-notice__warning");
        validationElement.classList.remove("s-notice__danger");
        validationElement.innerHTML = "";
    }
    showImagePreview(file) {
        const promise = new Promise((resolve, reject) => this.showImagePreviewAsync(file, resolve, reject));
        return promise;
    }
    showImagePreviewAsync(file, resolve, reject) {
        const previewElement = this.uploadContainer.querySelector(".js-image-preview");
        const addImageButton = this.uploadContainer.querySelector(".js-add-image");
        this.hideValidationError();
        const validationResult = this.validateImage(file);
        switch (validationResult) {
            case ValidationResult.FileTooLarge:
                this.showValidationError(_t("image_upload.upload_error_file_too_big"));
                reject("file too large");
                return;
            case ValidationResult.InvalidFileType:
                this.showValidationError(_t("image_upload.upload_error_unsupported_format"));
                reject("invalid filetype");
                return;
        }
        this.resetImagePreview();
        const reader = new FileReader();
        reader.addEventListener("load", () => {
            const image = new Image();
            image.className = "hmx1 w-auto";
            image.title = file.name;
            image.src = reader.result;
            image.alt = _t("image_upload.uploaded_image_preview_alt");
            previewElement.appendChild(image);
            previewElement.classList.remove("d-none");
            this.image = file;
            addImageButton.disabled = false;
            resolve();
        }, false);
        reader.readAsDataURL(file);
    }
    toggleExternalUrlInput(show) {
        const cta = this.uploadContainer.querySelector(".js-cta-container");
        const container = this.uploadContainer.querySelector(".js-external-url-input-container");
        cta.classList.toggle("d-none", show);
        container.classList.toggle("d-none", !show);
        container.querySelector(".js-external-url-input").value = "";
    }
    validateExternalUrl(url) {
        this.resetImagePreview();
        const addImageButton = this.uploadContainer.querySelector(".js-add-image");
        if (!this.validateLink(url)) {
            this.showValidationError(_t("image_upload.external_url_validation_error"), "danger");
            addImageButton.disabled = true;
        }
        else {
            this.hideValidationError();
            addImageButton.disabled = false;
        }
    }
    resetImagePreview() {
        this.uploadContainer.querySelector(".js-image-preview").innerHTML = "";
        this.image = null;
        this.uploadContainer.querySelector(".js-add-image").disabled = true;
    }
    resetUploader() {
        this.resetImagePreview();
        this.toggleExternalUrlInput(false);
        this.hideValidationError();
        this.uploadField.value = null;
    }
    handleUploadTrigger(event, file, view) {
        const externalUrl = this.uploadContainer.querySelector(".js-external-url-input").value;
        const urlIsValue = externalUrl && this.validateLink(externalUrl);
        if (!file && !urlIsValue) {
            return;
        }
        void this.startImageUpload(view, file || externalUrl);
        this.resetUploader();
        const tr = this.tryHideInterfaceTr(view.state);
        if (tr) {
            view.dispatch(tr);
        }
        view.focus();
    }
    startImageUpload(view, file) {
        var _a;
        // A fresh object to act as the ID for this upload
        const id = {};
        // Replace the selection with a placeholder
        const tr = view.state.tr;
        if (!tr.selection.empty)
            tr.deleteSelection();
        this.key.setMeta(tr, {
            add: { id, pos: tr.selection.from },
            // explicitly clear out any pasted/dropped file on upload
            file: null,
            shouldShow: false,
        });
        view.dispatch(tr);
        if (!((_a = this.uploadOptions) === null || _a === void 0 ? void 0 : _a.handler)) {
            // purposefully log an error to the dev console
            // don't use our internal `log` implementation, it only logs on dev builds
            // eslint-disable-next-line no-console
            console.error("No upload handler registered. Ensure you set a proper handler on the editor's options.imageUploadHandler");
            return;
        }
        return this.uploadOptions.handler(file).then((url) => {
            // ON SUCCESS
            // find where we inserted our placeholder so the content insert knows where to go
            const decos = this.key.getState(view.state).decorations;
            const found = decos.find(null, null, (spec) => spec.id == id);
            const pos = found.length ? found[0].from : null;
            // If the content around the placeholder has been deleted, drop the image
            if (pos === null)
                return;
            // get the transaction from the dispatcher
            let tr = this.addTransactionDispatcher(view.state, url, pos);
            // let the plugin know it can remove the upload decoration
            tr = this.key.setMeta(tr, {
                remove: { id },
                shouldShow: false,
                file: null,
            });
            view.dispatch(tr);
        }, () => {
            // ON ERROR
            // reshow the image uploader along with an error message
            let tr = this.tryShowInterfaceTr(view.state) || view.state.tr;
            // let the plugin know it can remove the upload decoration
            tr = this.key.setMeta(tr, {
                remove: { id },
                shouldShow: false,
                file: null,
            });
            view.dispatch(tr);
            this.showValidationError(_t("image_upload.upload_error_generic"), "error");
        });
    }
    update(view) {
        const state = this.key.getState(view.state);
        this.image = (state === null || state === void 0 ? void 0 : state.file) || this.image;
        super.update(view);
    }
    destroy() {
        this.uploadField.remove();
        this.uploadContainer.remove();
        this.image = null;
    }
    buildInterface(container) {
        if (this.image) {
            void this.showImagePreview(this.image);
        }
        // add the upload container to the menu area
        container.appendChild(this.uploadContainer);
        this.uploadContainer
            .querySelector(".js-image-uploader-input")
            .focus();
    }
    destroyInterface(container) {
        this.resetUploader();
        this.uploadContainer.classList.remove("outline-ring");
        container.removeChild(this.uploadContainer);
    }
}
/**
 * Hides the image uploader
 * @param view The current editor view
 */
export function hideImageUploader(view) {
    const tr = INTERFACE_KEY.hideInterfaceTr(view.state, {
        file: null,
    });
    if (tr) {
        view.dispatch(tr);
    }
}
/** Shows the image uploader
 * @param view The current editor view
 * @param file The file to upload
 */
export function showImageUploader(view, file) {
    const tr = INTERFACE_KEY.showInterfaceTr(view.state, {
        file: file || null,
    });
    if (tr) {
        view.dispatch(tr);
    }
}
/**
 * Checks if the image-upload functionality is enabled
 * @param state The current editor state
 */
export function imageUploaderEnabled(state) {
    const pluginState = INTERFACE_KEY.getState(state);
    return !!pluginState;
}
/**
 * Creates a placeholder decoration to indicate to the user that the image is currently uploading;
 * Gets replaced with the actual image markup on upload completion
 */
function createPlaceholder() {
    const placeholder = document.createElement("div");
    placeholder.className = "ws-normal d-block m8";
    placeholder.innerHTML = `
<div class="py6 px6 bg-black-050 bar-sm gsx gs8 d-inline-flex ai-center fw-normal fs-body1">
    <span class="s-spinner s-spinner__sm flex--item">
        <span class="v-visible-sr">Loading…</span>
    </span>
    <span class="flex--item">Uploading image…</span>
</div>
`;
    return placeholder;
}
/**
 * Adds image uploading capabilities to the editor.
 * With this plugin, you'll be able to show a popover that allows you to
 * browse for files on your file system, or use drag & drop to select images
 * to upload.
 *
 * On upload, this plugin will call the provided uploadHandler function .
 * @see defaultImageUploadHandler for an example
 *
 * @param uploadHandler A function handling file uploads. Will receive the file to upload
 * as the `file` parameter and needs to return a resolved promise with the URL of the uploaded file
 * @param containerFn A function that returns the container to insert the plugin's UI into
 * @param addTransactionDispatcher Dispatcher function that generates a transaction to dispatch to the view on image add
 */
function imageUploaderPlaceholderPlugin(uploadOptions, validateLink, addTransactionDispatcher) {
    // if the required image upload options are missing, don't enable the plugin at all
    if (!(uploadOptions === null || uploadOptions === void 0 ? void 0 : uploadOptions.handler)) {
        return new Plugin({});
    }
    return new StatefulPlugin({
        key: INTERFACE_KEY,
        state: {
            init() {
                return {
                    decorations: DecorationSet.empty,
                    file: null,
                    shouldShow: false,
                };
            },
            apply(tr, state) {
                let set = state.decorations || DecorationSet.empty;
                // Adjust decoration positions to changes made by the transaction
                set = set.map(tr.mapping, tr.doc);
                const metadata = this.getMeta(tr);
                const returnValue = {
                    file: state.file,
                    decorations: set,
                    shouldShow: state.shouldShow,
                };
                // if no metadata was set, do not alter this state further
                if (!metadata) {
                    return returnValue;
                }
                if ("file" in metadata) {
                    returnValue.file = metadata.file;
                }
                else {
                    returnValue.file = null;
                }
                if ("shouldShow" in metadata) {
                    returnValue.shouldShow = metadata.shouldShow;
                }
                // See if the transaction adds or removes any placeholders
                if (metadata.add) {
                    const deco = Decoration.widget(metadata.add.pos, createPlaceholder(), {
                        id: metadata.add.id,
                    });
                    returnValue.decorations = set.add(tr.doc, [deco]);
                }
                else if (metadata.remove) {
                    returnValue.decorations = set.remove(set.find(null, null, (spec) => spec.id == metadata.remove.id));
                }
                return returnValue;
            },
        },
        props: {
            decorations(state) {
                return this.getState(state).decorations;
            },
            handleDrop(view, event) {
                const files = event.dataTransfer.files;
                if (view.state.selection.$from.parent.inlineContent &&
                    files.length) {
                    showImageUploader(view, files[0]);
                    return true;
                }
                return false;
            },
            handlePaste(view, event) {
                const files = event.clipboardData.files;
                if (view.state.selection.$from.parent.inlineContent &&
                    files.length) {
                    showImageUploader(view, files[0]);
                    return true;
                }
                return false;
            },
        },
        view(editorView) {
            return new ImageUploader(editorView, uploadOptions, validateLink, addTransactionDispatcher);
        },
    });
}
/** Singleton instance of the plugin key for exported show/hide methods to reference */
const INTERFACE_KEY = new ManagedInterfaceKey("image-uploader");
/**
 * Adds image uploading capabilities to the editor.
 * With this plugin, you'll be able to show a popover that allows you to
 * browse for files on your file system, or use drag & drop to select images
 * to upload.
 *
 * On upload, this plugin will call the provided uploadOptions.handler function
 * @see defaultImageUploadHandler for an example
 *
 * @param uploadOptions The imageUpload options
 * @param containerFn A function that returns the container to insert the plugin's UI into
 */
export function richTextImageUpload(uploadOptions, validateLink, schema) {
    return imageUploaderPlaceholderPlugin(uploadOptions, validateLink, (state, url, pos) => {
        const defaultAltText = _t("image_upload.default_image_alt_text");
        const marks = uploadOptions.wrapImagesInLinks ||
            uploadOptions.embedImagesAsLinks
            ? [schema.marks.link.create({ href: url })]
            : null;
        const imgNode = uploadOptions.embedImagesAsLinks
            ? schema.text(defaultAltText, marks)
            : schema.nodes.image.create({ src: url, alt: defaultAltText }, null, marks);
        return state.tr.replaceWith(pos, pos, imgNode);
    });
}
//TODO markdown upload decoration doesn't really fit in visually, make it more... ascii art-ish?
/**
 * Adds image uploading capabilities to the editor.
 * With this plugin, you'll be able to show a popover that allows you to
 * browse for files on your file system, or use drag & drop to select images
 * to upload.
 *
 * On upload, this plugin will call the provided uploadOptions.handler function
 * @see defaultImageUploadHandler for an example
 *
 * @param uploadHandler The imageUpload options
 * @param containerFn A function that returns the container to insert the plugin's UI into
 */
export function commonmarkImageUpload(uploadOptions, validateLink) {
    return imageUploaderPlaceholderPlugin(uploadOptions, validateLink, (state, url, pos) => {
        const defaultAltText = _t("image_upload.default_image_alt_text");
        // construct the raw markdown
        let mdString = `![${defaultAltText}](${url})`;
        let selectionStart = pos + 2;
        let selectionEnd = selectionStart + defaultAltText.length;
        if (uploadOptions.embedImagesAsLinks) {
            // strip off the leading `!`
            mdString = mdString.slice(1);
            selectionStart -= 1;
            selectionEnd -= 1;
        }
        else if (uploadOptions.wrapImagesInLinks) {
            mdString = `[${mdString}](${url})`;
            selectionStart += 1;
            selectionEnd += 1;
        }
        // insert into the document
        const tr = state.tr.insertText(mdString, pos);
        // pre-select the alt text so the user can just start typing after insert
        // NOTE: these are not magic numbers, just hardcoded indexes for the above string
        tr.setSelection(TextSelection.create(state.apply(tr).doc, selectionStart, selectionEnd));
        return tr;
    });
}
