import OrderedMap from "orderedmap";
/**
 * {@inheritDoc IExternalPluginProvider}
 * @internal
 */
export class ExternalPluginProvider {
    constructor(plugins, options) {
        this._codeblockProcessors = {};
        this._plugins = {
            richText: [],
            commonmark: [],
        };
        this._markdownProps = {
            parser: {},
            serializers: {
                nodes: {},
                marks: {},
            },
        };
        this._nodeViews = {};
        this.menuCallbacks = [];
        this.schemaCallbacks = [];
        this.markdownItCallbacks = [];
        if (plugins === null || plugins === void 0 ? void 0 : plugins.length) {
            for (const plugin of plugins) {
                this.applyConfig(plugin(options));
            }
        }
    }
    /** {@inheritDoc IExternalPluginProvider.codeblockProcessors} */
    get codeblockProcessors() {
        return Object.assign({}, this._codeblockProcessors);
    }
    /** {@inheritDoc IExternalPluginProvider.plugins} */
    get plugins() {
        return this._plugins;
    }
    /** {@inheritDoc IExternalPluginProvider.markdownProps} */
    get markdownProps() {
        return this._markdownProps;
    }
    /** {@inheritDoc IExternalPluginProvider.nodeViews} */
    get nodeViews() {
        return this._nodeViews;
    }
    /** {@inheritDoc IExternalPluginProvider.getFinalizedSchema} */
    getFinalizedSchema(schema) {
        let alteredSchema = {
            nodes: OrderedMap.from(schema.nodes),
            marks: OrderedMap.from(schema.marks),
        };
        for (const callback of this.schemaCallbacks) {
            if (callback) {
                alteredSchema = callback(alteredSchema);
            }
        }
        return alteredSchema;
    }
    /** {@inheritDoc IExternalPluginProvider.alterMarkdownIt} */
    alterMarkdownIt(instance) {
        for (const callback of this.markdownItCallbacks) {
            if (callback) {
                callback(instance);
            }
        }
    }
    /** {@inheritDoc IExternalPluginProvider.getFinalizedMenu} */
    getFinalizedMenu(menu, schema) {
        var _a;
        const ret = [];
        const aggBlocks = [];
        // call each callback and aggregate the results
        for (const callback of [() => menu, ...this.menuCallbacks]) {
            if (!callback) {
                continue;
            }
            const blocks = callback(schema);
            for (const block of blocks) {
                let existing = aggBlocks.find((b) => b.name === block.name);
                if (!existing) {
                    aggBlocks.push(block);
                    existing = block;
                }
                else {
                    existing.entries.push(...block.entries);
                }
                // set the priority to the most recently declared if there are multiple
                existing.priority = (_a = block.priority) !== null && _a !== void 0 ? _a : Infinity;
            }
        }
        // add the blocks to the menu
        for (const block of aggBlocks) {
            // try to find an existing block with the same name
            const match = ret.find((b) => b.name === block.name);
            if (match) {
                // if there is a match, add the entries to it
                match.entries.push(...block.entries);
                // set the priority to the lowest of the two
                match.priority = Math.min(match.priority || 0, block.priority);
            }
            else {
                ret.push({
                    name: block.name,
                    priority: block.priority,
                    visible: block.visible,
                    classes: block.classes,
                    entries: block.entries,
                });
            }
        }
        return ret;
    }
    /** Applies the config of a single plugin to this provider */
    applyConfig(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        (_a = config.codeBlockProcessors) === null || _a === void 0 ? void 0 : _a.forEach(({ lang, callback }) => {
            this.addCodeBlockProcessor(lang, callback);
        });
        (_c = (_b = config.commonmark) === null || _b === void 0 ? void 0 : _b.plugins) === null || _c === void 0 ? void 0 : _c.forEach((plugin) => {
            this._plugins.commonmark.push(plugin);
        });
        (_e = (_d = config.richText) === null || _d === void 0 ? void 0 : _d.plugins) === null || _e === void 0 ? void 0 : _e.forEach((plugin) => {
            this._plugins.richText.push(plugin);
        });
        this.schemaCallbacks.push(config.extendSchema);
        if ((_f = config.richText) === null || _f === void 0 ? void 0 : _f.nodeViews) {
            this._nodeViews = Object.assign(Object.assign({}, this._nodeViews), (_g = config.richText) === null || _g === void 0 ? void 0 : _g.nodeViews);
        }
        this.extendMarkdown(config.markdown, (_h = config.markdown) === null || _h === void 0 ? void 0 : _h.alterMarkdownIt);
        this.menuCallbacks.push(config.menuItems);
    }
    /** Applies the markdownProps of a config to this provider */
    extendMarkdown(props, callback) {
        var _a, _b;
        // TODO sanitize input to ensure nodes/marks for added parsers and vice versa?
        if (props === null || props === void 0 ? void 0 : props.parser) {
            this._markdownProps.parser = Object.assign(Object.assign({}, this._markdownProps.parser), props.parser);
        }
        if ((_a = props === null || props === void 0 ? void 0 : props.serializers) === null || _a === void 0 ? void 0 : _a.nodes) {
            this._markdownProps.serializers.nodes = Object.assign(Object.assign({}, this._markdownProps.serializers.nodes), props.serializers.nodes);
        }
        if ((_b = props === null || props === void 0 ? void 0 : props.serializers) === null || _b === void 0 ? void 0 : _b.marks) {
            this._markdownProps.serializers.marks = Object.assign(Object.assign({}, this._markdownProps.serializers.marks), props.serializers.marks);
        }
        if (callback) {
            this.markdownItCallbacks.push(callback);
        }
    }
    /** Applies the codeblockProcessors of a config to this provider */
    addCodeBlockProcessor(lang, callback) {
        if (!(lang in this._codeblockProcessors)) {
            this._codeblockProcessors[lang] = [];
        }
        this._codeblockProcessors[lang].push(callback);
    }
}
