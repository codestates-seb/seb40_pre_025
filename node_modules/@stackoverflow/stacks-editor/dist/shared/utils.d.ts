import { Command, EditorState } from "prosemirror-state";
/**
 * Recursively deep merges two objects into a new object, leaving the original two untouched
 * NOTE: Arrays are only shallow merged
 * @param object1 The object to base the merge off of
 * @param object2 The object to merge into the base object
 */
export declare function deepMerge(object1: unknown, object2: unknown): unknown;
/**
 * Compares two states and returns true if the doc has changed between them.
 * The doc is considered changed if:
 *      * its content changed
 *      * the stored marks have changed
 * @param prevState The "old" / previous editor state
 * @param newState The "new" / current editor state
 */
export declare function docNodeChanged(prevState: EditorState, newState: EditorState): boolean;
/**
 * Compares two states and returns true if the doc has changed between them.
 * The doc is considered changed if:
 *      * the document node changed (@see docNodeChanged)
 *      * the selection has changed
 * @param prevState The "old" / previous editor state
 * @param newState The "new" / current editor state
 */
export declare function docChanged(prevState: EditorState, newState: EditorState): boolean;
/**
 * Returns the text node the cursor is currently anchored in
 * @param state The current editor state
 * @returns A text node or null if the cursor is not in a text node
 */
export declare function getCurrentTextNode(state: EditorState): import("prosemirror-model").Node;
export declare type StickyChangeDetails = {
    target: Element;
    stuck: boolean;
};
/** The class to attach sticky observers to */
export declare const STICKY_OBSERVER_CLASS = "js-sticky";
/**
 * Starts observers watching all .STICKY_OBSERVER_CLASS elements for a change in stuck position
 * @param container The container to search for STICKY_OBSERVER_CLASS elements (usually the closest scrolling parent)
 * @fires sticky-change
 */
export declare function startStickyObservers(container: Element): void;
/**
 * Checks if a url is well-formed and passes Stack Overflow's validation checks
 * @param url The url to validate
 */
export declare function stackOverflowValidateLink(url: string): boolean;
/**
 * Template function to escape all html in substitutions, but not the rest of the template.
 * For instance, escapeHTML`<p>${"<span>user input</span>"}</p>` will escape the inner span, but not the outer p tags.
 * Uses markdown-it's @see escapeHtml in the background
 */
export declare function escapeHTML(strings: TemplateStringsArray, ...subs: unknown[]): string;
/** Gets the modifier key for the current platform; i.e. "Command" on macOS and "Control" elsewhere */
export declare function getPlatformModKey(): "Cmd" | "Ctrl";
/**
 * Returns a string containing the label and readable keyboard shortcut for button tooltips
 * @param mapping Corresponding command mapping (keyboard shortcut)
 */
export declare function getShortcut(mapping: string): string;
/**
 * Generated a random id that can be used to ensure DOM element ids are unique
 * @returns a random string
 */
export declare function generateRandomId(): string;
/**
 * Prefixes and dispatches a custom event on the target
 * @param target The target to dispatch the event on
 * @param eventName The unprefixed event name
 * @param detail Any custom data to pass on the event
 * @returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise
 */
export declare function dispatchEditorEvent(target: Element, eventName: string, detail?: unknown): boolean;
/** Helper type that recursively makes an object and all its children Partials */
export declare type PartialDeep<T> = {
    [key in keyof T]?: PartialDeep<T[key]>;
};
/**
 * Binds a keymap containing a letter to both the lowercase and uppercase version of that letter;
 * this is done so that when the user has CAPS LOCK on, the keymap will still work
 * @param mapping The keymap string to bind
 * @param command The command to bind to all generated keymaps
 */
export declare function bindLetterKeymap(mapping: string, command: Command): {
    [key: string]: Command;
};
/**
 * Sets attributes from an object onto an html element;
 * style, class* and on* attributes will be ignored;
 * @param el The element to set the attributes on
 * @param attrs The key/value attributes to set onto the element
 * @internal
 */
export declare function setAttributesOnElement(el: HTMLElement, attrs: Record<string, unknown>): void;
