var w = Object.defineProperty;
var x = (o, e, n) => e in o ? w(o, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : o[e] = n;
var k = (o, e, n) => (x(o, typeof e != "symbol" ? e + "" : e, n), n);
import { TreeFragment as C } from "@lezer/common";
import { highlightTree as A, classHighlighter as B } from "@lezer/highlight";
import { Decoration as H, DecorationSet as v } from "prosemirror-view";
import { PluginKey as O, Plugin as P } from "prosemirror-state";
function S(o, e) {
  const n = [];
  return e.includes("doc") && n.push({ node: o, pos: -1 }), o.descendants((a, r) => {
    if (a.isBlock && e.indexOf(a.type.name) > -1)
      return n.push({
        node: a,
        pos: r
      }), !1;
  }), n;
}
function E(o, e, n, a, r) {
  if (!o || !o.nodeSize || !(n != null && n.length) || !a)
    return [];
  const i = S(o, n);
  let l = [];
  return i.forEach((t) => {
    var d;
    let c;
    r != null && r.preRenderer && (c = (d = r.preRenderer(t.node, t.pos)) != null ? d : void 0);
    const s = a(t.node) || "*", h = e[s] || e["*"] || null;
    if (!h)
      return;
    const g = h.parse(t.node.textContent, c), u = [];
    A(g, (r == null ? void 0 : r.highlighter) || B, (f, m, p) => {
      const D = H.inline(f + t.pos + 1, m + t.pos + 1, {
        class: p
      });
      u.push(D);
    }), r != null && r.postRenderer && r.postRenderer(t.node, t.pos, C.addTree(g)), l = [...l, ...u];
  }), l;
}
class R {
  constructor(e) {
    k(this, "cache");
    this.cache = { ...e };
  }
  get(e) {
    return this.cache[e] || null;
  }
  set(e, n, a) {
    e < 0 || (this.cache[e] = { node: n, fragments: a });
  }
  replace(e, n, a, r) {
    this.remove(e), this.set(n, a, r);
  }
  remove(e) {
    delete this.cache[e];
  }
  invalidate(e) {
    const n = new R(this.cache), a = e.mapping;
    return Object.keys(this.cache).forEach((r) => {
      const i = +r;
      if (i < 0)
        return;
      const l = a.mapResult(i), t = e.doc.nodeAt(l.pos), { node: c, fragments: s } = this.get(i), h = e.mapping.maps.flatMap((g) => {
        const u = [];
        return g.forEach((d, f, m, p) => {
          u.push({
            fromA: d,
            toA: f,
            fromB: m,
            toB: p
          });
        }), u;
      });
      l.deleted || !(t != null && t.eq(c)) ? n.remove(i) : i !== l.pos && n.replace(i, l.pos, t, C.applyChanges(s, h));
    }), n;
  }
}
function y(o, e = ["code_block"], n, a) {
  const r = n || function(t) {
    const c = t.attrs.detectedHighlightLanguage, s = t.attrs.params;
    return c || (s == null ? void 0 : s.split(" ")[0]) || "";
  }, i = (t, c) => ({ content: E(t, o, e, r, {
    preRenderer: (h, g) => {
      var u;
      return (u = c.get(g)) == null ? void 0 : u.fragments;
    },
    postRenderer: (h, g, u) => {
      c.set(g, h, u);
    },
    highlighter: a
  }) }), l = new O();
  return new P({
    key: l,
    state: {
      init(t, c) {
        const s = new R({}), h = i(c.doc, s);
        return {
          cache: s,
          decorations: v.create(c.doc, h.content)
        };
      },
      apply(t, c) {
        const s = c.cache.invalidate(t);
        if (!t.docChanged)
          return {
            cache: s,
            decorations: c.decorations.map(t.mapping, t.doc)
          };
        const h = i(t.doc, s);
        return {
          cache: s,
          decorations: v.create(t.doc, h.content)
        };
      }
    },
    props: {
      decorations(t) {
        var c;
        return (c = this.getState(t)) == null ? void 0 : c.decorations;
      }
    }
  });
}
export {
  R as TreeFragmentCache,
  E as getHighlightDecorations,
  y as highlightPlugin
};
